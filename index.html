<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiverse Run: Arcade</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.292.0"
      }
    }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        @keyframes bounce-slow {
            0%, 100% { transform: translateY(-5%); }
            50% { transform: translateY(5%); }
        }
        .animate-bounce-slow {
            animation: bounce-slow 2s infinite;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .gem-glow {
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.8));
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Dice5, LogOut, ArrowRight, Skull, RefreshCcw, 
            ArrowUp, ArrowDown, Footprints, Crown, Trophy, 
            Zap, Bomb, Flag, Flame, Ghost, ShieldAlert, Pointer, Dices, Info, Medal, User, X, ChevronsUp, Users, Shield, AlertCircle, Shuffle, Gem, Biohazard, ArrowLeft
        } from 'lucide-react';

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken,
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc, 
            arrayUnion 
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // --- CONFIGURAZIONE FIREBASE ---
        const firebaseConfig = {
            apiKey: "AIzaSyDTaGJcSOVHg3_2K5SgcrDfANtdn0ewb6s",
            authDomain: "gioco-oca-pincher.firebaseapp.com",
            projectId: "gioco-oca-pincher",
            storageBucket: "gioco-oca-pincher.firebasestorage.app",
            messagingSenderId: "41567402648",
            appId: "1:41567402648:web:292e0567e58e814276aeed",
            measurementId: "G-RCF5K88KPN"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        
        const appId = 'multiverse_goose_game_v2'; 

        // --- TEAM COLORS ---
        const TEAM_COLORS = [
            { name: "Rosso", bg: "bg-red-500", border: "border-red-500", text: "text-red-500", light: "bg-red-100" },
            { name: "Blu", bg: "bg-blue-500", border: "border-blue-500", text: "text-blue-500", light: "bg-blue-100" },
            { name: "Verde", bg: "bg-green-500", border: "border-green-500", text: "text-green-500", light: "bg-green-100" },
            { name: "Giallo", bg: "bg-yellow-500", border: "border-yellow-500", text: "text-yellow-600", light: "bg-yellow-100" }
        ];

        // --- ROSTER DATI ---
        const ROSTER = [
        { name: "Marinette", img: "https://i.pinimg.com/736x/b8/74/55/b87455575cd069609007a639c9490293.jpg", dice: { name: "Dado Fortunato", vals: [0, 2, 4, 4, 4, 5], color: "bg-pink-500", text: "text-pink-500", desc: "Niente rischi, solo progressi costanti." } },
        { name: "Adrien", img: "https://i.pinimg.com/1200x/5c/2d/c7/5c2dc740ed2fe906b6afaf1320bf4273.jpg", dice: { name: "Dado Cataclisma", vals: [-2, -1, 0, 3, 6, 9], color: "bg-gray-800", text: "text-gray-800", desc: "Estremi pericolosi: o voli o crolli." } },
        { name: "Re Julien", img: "https://i.pinimg.com/736x/1e/17/19/1e17194ef5b383e4202fbb4875cfbd81.jpg", dice: { name: "Dado da Re", vals: [2, 2, 2, 2, 2, 3], color: "bg-yellow-500", text: "text-yellow-500", desc: "Un re non corre, incede con grazia." } },
        { name: "Gwen", img: "https://i.pinimg.com/1200x/59/d7/15/59d71578cd5f889ae898bbc83dda29dc.jpg", dice: { name: "Dado Solitario", vals: [3, 3, 3, 3, 3, 3], color: "bg-teal-600", text: "text-teal-600", desc: "La coerenza è la chiave della vittoria." } },
        { name: "Heather", img: "https://i.pinimg.com/736x/81/5b/b6/815bb632721e7d38f26d35801466dd30.jpg", dice: { name: "Dado Villain", vals: [-1, 1, 2, 2, 6, 8], color: "bg-purple-800", text: "text-purple-800", desc: "Pianifica, indietreggia, colpisci duro." } },
        { name: "Lindsay", img: "https://i.pinimg.com/1200x/ed/96/df/ed96df179eaa7030663473c575067cb4.jpg", dice: { name: "Dado Stupido", vals: [-6, 0, 0, 0, 0, 10], color: "bg-orange-300", text: "text-orange-500", desc: "O disastro totale o miracolo assoluto." } },
        { name: "Yoshi", img: "https://i.pinimg.com/736x/f3/05/7f/f3057f14de68b0afe682ffe93dcc479b.jpg", dice: { name: "Dado Uovo", vals: [2, 2, 2, 3, 3, 3], color: "bg-green-500", text: "text-green-500", desc: "Piccoli saltelli felici verso la meta." } },
        { name: "Wario", img: "https://i.pinimg.com/736x/2f/ea/be/2feabe47151fd436fbf358c299eb4870.jpg", dice: { name: "Dado WAH?", vals: [0, 0, 0, 2, 6, 6], color: "bg-yellow-600", text: "text-yellow-700", desc: "Pigrizia o avidità, niente vie di mezzo." } },
        { name: "Tanjiro", img: "https://i.pinimg.com/736x/e9/6d/20/e96d20e7c159897a05c6baa57fac7f35.jpg", dice: { name: "Dado d'Acqua", vals: [0, 1, 2, 5, 6, 7], color: "bg-cyan-500", text: "text-cyan-600", desc: "Fluido come l'acqua, a volte calmo a volte impetuoso." } },
        { name: "Mr Krab", img: "https://i.pinimg.com/1200x/74/9c/f5/749cf53dd48dbb440fcde8d958c7dbb1.jpg", dice: { name: "Dado Greedy", vals: [-2, -2, -2, 8, 8, 8], color: "bg-red-600", text: "text-red-600", desc: "Rischia tutto per il malloppo grosso." } },
        { name: "Gumball", img: "https://i.pinimg.com/736x/ae/88/e3/ae88e329120b3edc196af1ebbfd8fe07.jpg", dice: { name: "Dado Caotico", vals: [0, 0, 3, 3, 3, 6], color: "bg-blue-400", text: "text-blue-500", desc: "Un disastro controllato." } },
        { name: "Johnny Bravo", img: "https://i.pinimg.com/736x/4a/62/70/4a6270678f7adcf130672bcd0af41fdf.jpg", dice: { name: "Dado Oh Yeah", vals: [0, 0, 1, 6, 7, 8], color: "bg-black", text: "text-black", desc: "Fatti bello e spera nel meglio." } },
        { name: "Steven", img: "https://i.pinimg.com/736x/2b/fd/20/2bfd202ab782611ea6a0fb0cdcdc37ab.jpg", dice: { name: "Dado Diamantato", vals: [1, 1, 1, 1, 2, 3], color: "bg-pink-300", text: "text-pink-400", desc: "Lento e protettivo, ma sicuro." } },
        { name: "Ariana Grande", img: "https://media.tenor.com/1u94p6qR01gAAAAM/ariana-grande-eternal-sunshine.gif", dice: { name: "Dado YUH", vals: [0, 0, 1, 5, 6, 8], color: "bg-indigo-300", text: "text-indigo-400", desc: "Note alte e passi lunghi (se canti)." } },
        { name: "Will", img: "https://i.pinimg.com/originals/88/80/73/8880736b5695844044e0e38c8063a1ff.gif", dice: { name: "Dado Rainbow", vals: [3, 3, 3, 3, 3, 6], color: "bg-indigo-500", text: "text-indigo-500", desc: "Costante con un tocco di favolosità." } },
        { name: "Carlos Oliveira", img: "https://i.pinimg.com/originals/32/0d/d1/320dd13031f1aba8a2d3d9b9837174f4.gif", dice: { name: "Dado Peloso", vals: [-2, 0, 2, 4, 6, 8], color: "bg-orange-800", text: "text-orange-800", desc: "Selvaggio e imprevedibile." } },
        { name: "Leon", img: "https://i.pinimg.com/736x/db/ef/fc/dbeffc6e915a929f7dbe908390f5af42.jpg", dice: { name: "Dado Carismatico", vals: [2, 2, 2, 5, 5, 5], color: "bg-blue-800", text: "text-blue-800", desc: "Solo numeri stilosi." } },
        { name: "Finn", img: "https://i.pinimg.com/736x/7e/0b/c9/7e0bc9826a7652264f32a44bc8a40ede.jpg", dice: { name: "Dado Cauto", vals: [1, 1, 1, 1, 1, 1], color: "bg-blue-300", text: "text-blue-400", desc: "Un passo alla volta, eroe." } },
        { name: "Jake", img: "https://i.pinimg.com/1200x/cd/77/22/cd7722b2f98ffc75d1128913df6861d7.jpg", dice: { name: "Dado Rischioso", vals: [-3, -3, -3, 7, 8, 8], color: "bg-yellow-400", text: "text-yellow-600", desc: "Allungati troppo e torni indietro." } },
        { name: "Stewie", img: "https://i.pinimg.com/1200x/1e/a2/cc/1ea2cc7a197e3841086f4a1ce18b089c.jpg", dice: { name: "Genio del Male", vals: [1, 3, 5, 6, 7, 7], color: "bg-red-500", text: "text-red-500", desc: "Piani complessi per grandi risultati." } },
        { name: "Peter", img: "https://i.pinimg.com/736x/9e/40/74/9e4074bbe7890cd245b51b9ff5c0e33c.jpg", dice: { name: "Dado Affamato", vals: [1, 2, 2, 2, 7, 8], color: "bg-green-600", text: "text-green-700", desc: "Corri verso il buffet." } },
        { name: "Ashley", img: "https://i.pinimg.com/736x/d1/c5/5f/d1c55f57218baecf0c2e160155e80c61.jpg", dice: { name: "Dado Ti Amo", vals: [3, 3, 3, 3, 3, 3], color: "bg-red-400", text: "text-red-400", desc: "Amore costante e ripetitivo." } },
        { name: "Nicole", img: "https://i.pinimg.com/736x/81/24/e4/8124e43da43e1d06dcdbca15f22a0cd9.jpg", dice: { name: "Dado Materno", vals: [0, 0, 2, 5, 5, 5], color: "bg-blue-500", text: "text-blue-600", desc: "Severa ma giusta." } },
        { name: "Lapis", img: "https://i.pinimg.com/1200x/09/fb/12/09fb12467957da96913fc8f75e6f6356.jpg", dice: { name: "Dado Tsunami", vals: [-4, -2, 0, 6, 8, 10], color: "bg-blue-600", text: "text-blue-600", desc: "La forza dell'oceano: devastante o ritirata." } }
        ].map((c, i) => ({ ...c, id: i }));

        // --- SOUND ENGINE ---
        const playSound = (type) => {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                const now = ctx.currentTime;
                
                if (type === 'click') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(600, now);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'step') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
                    gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now); osc.stop(now + 0.1);
                } else if (type === 'gem') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1000, now);
                    osc.frequency.linearRampToValueAtTime(2000, now + 0.2);
                    gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now); osc.stop(now + 0.3);
                } else if (type === 'zombie') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(100, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.4, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                    osc.start(now); osc.stop(now + 0.5);
                }
            } catch (e) { console.error(e); }
        };

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- MAPPE DI GIOCO ---
        const CLASSIC_MAP = {
        max: 60,
        specials: {
            6: { type: 'JUMP', val: 12, name: 'Ponte', icon: <ArrowRight />, desc: "Attraversa il ponte! Vai direttamente alla casella 12." },
            16: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            19: { type: 'WAIT', turns: 2, name: 'Pozzo', icon: <RefreshCcw />, desc: "Sei caduto nel Pozzo! Devi aspettare 2 turni per risalire." }, 
            25: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Ti metti in scia! Ti teletrasporti subito dietro al giocatore che ti precede in classifica." },
            31: { type: 'WAIT', turns: 2, name: 'Pozzo 2', icon: <RefreshCcw />, desc: "Un altro pozzo! Aspetta 2 turni." },
            42: { type: 'BACK', val: 30, name: 'Labirinto', icon: <ArrowDown />, desc: "Ti sei perso nel Labirinto! Torni indietro alla casella 30." },
            48: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            52: { type: 'WAIT', turns: 2, name: 'Prigione', icon: <ShieldAlert />, desc: "Sei stato arrestato! Rimani in Prigione per 2 turni." },
            58: { type: 'RESTART', name: 'Scheletro', icon: <Skull />, desc: "Lo Scheletro ti ha spaventato! Torni all'inizio (START)." },
            5: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            9: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! Corri avanti di 3 caselle." },
            14: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
            23: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Scivolata nel fango! Torni indietro di 2 caselle." },
            27: { type: 'BOOST', val: -1, name: '-1', icon: <ArrowDown />, desc: "Vento contrario! Torni indietro di 1 casella." },
            36: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! Corri avanti di 3 caselle." },
            38: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "Super Bonus! Avanzi ancora del risultato che hai appena fatto x2!" }, 
            50: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Scivolata nel fango! Torni indietro di 2 caselle." },
            54: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Un piccolo aiuto: avanza di 2 caselle." },
        }
        };

        const ELIM_MAP = {
        max: 34,
        specials: {
            3: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint iniziale! +3 caselle." },
            7: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Sprint! +3 caselle." },
            8: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "Super Bonus! Avanzi ancora del risultato che hai appena fatto x2!" }, 
            12: { type: 'BACK', val: 5, name: 'Trappola', icon: <Bomb />, desc: "È una trappola! Torni alla casella 5." },
            15: { type: 'BOOST', val: 4, name: '+4', icon: <Zap />, desc: "Mega Sprint! Corri avanti di 4 caselle." },
            17: { type: 'TAIL', name: 'In Coda', icon: <Footprints />, desc: "Ti metti in scia! Ti teletrasporti dietro al giocatore davanti a te." },
            20: { type: 'BACK', val: 10, name: 'Labirinto', icon: <ArrowDown />, desc: "Labirinto insidioso! Torni alla casella 10." }, 
            25: { type: 'BACK', val: 18, name: 'Tornado', icon: <ArrowDown />, desc: "Un tornado ti spazza via! Torni alla 18." },
            26: { type: 'TELEPORT', name: 'Teletrasporto', icon: <Shuffle />, desc: "Scambio dimensionale! Vai nella casella di un giocatore a caso." },
            32: { type: 'BOOST', val: -2, name: '-2', icon: <ArrowDown />, desc: "Sei quasi alla fine ma scivoli! Indietro di 2." },
        }
        };

        const GEM_MAP = {
            max: 50,
            specials: {
                5: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Avanza di 2" },
                12: { type: 'BOOST', val: 1, name: '+1', icon: <ArrowUp />, desc: "Avanza di 1" },
                18: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Avanza di 3" },
                22: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento" },
                30: { type: 'BOOST', val: 2, name: '+2', icon: <ArrowUp />, desc: "Avanza di 2" },
                38: { type: 'BOOST', val: 3, name: '+3', icon: <Zap />, desc: "Avanza di 3" },
                45: { type: 'DOUBLE', name: 'Raddoppia', icon: <ChevronsUp />, desc: "X2 Movimento" }
            }
        };

        const PlayerAvatar = ({ charId, size = "md", border = true }) => {
        const s = size === 'sm' ? 'w-8 h-8' : size === 'lg' ? 'w-16 h-16' : 'w-10 h-10';
        // SAFETY GUARD: Use default character if out of bounds
        const safeCharId = (charId >= 0 && charId < ROSTER.length) ? charId : 0;
        return (
            <img src={ROSTER[safeCharId].img} className={`${s} rounded-full object-cover ${border ? 'border-2 border-white shadow-sm' : ''}`} alt="Avatar" />
        );
        };

        const BoardCell = ({ num, players, special, isElimination, isPendingTarget, onCellClick, onInfoClick, gems, infected }) => {
            let bgClass = "bg-slate-100";
            let borderClass = "border-slate-300";
            let cursorClass = "cursor-pointer"; 
            let highlightClass = "";
            
            const hasGem = gems && gems.includes(num);

            if (num === 0) { bgClass = "bg-green-200"; borderClass = "border-green-400"; }
            else if (num === (isElimination ? 34 : (special && !special.max ? 60 : 50))) { bgClass = "bg-yellow-200"; borderClass = "border-yellow-400"; }
            else if (special) {
                if (special.type === 'BOOST' && special.val > 0 || special.type === 'JUMP' || special.type === 'DOUBLE') { bgClass = "bg-cyan-100"; borderClass = "border-cyan-300"; }
                else if ((special.type === 'BOOST' && special.val < 0) || special.type === 'BACK' || special.type === 'RESTART') { bgClass = "bg-red-100"; borderClass = "border-red-300"; }
                else if (special.type === 'WAIT') { bgClass = "bg-slate-300"; borderClass = "border-slate-500"; }
                else if (special.type === 'TAIL' || special.type === 'TELEPORT') { bgClass = "bg-purple-200"; borderClass = "border-purple-400"; }
            }

            if (hasGem) {
                bgClass = "bg-indigo-900";
                borderClass = "border-yellow-400";
            }

            if (isPendingTarget) {
                highlightClass = "ring-4 ring-yellow-400 ring-offset-2 animate-pulse z-20 shadow-xl bg-yellow-50 scale-105";
                cursorClass = "cursor-pointer hover:bg-yellow-100";
            }

            return (
                <div 
                onClick={() => {
                    if (isPendingTarget) onCellClick();
                    else if (special) onInfoClick(special);
                }}
                className={`relative w-full aspect-square border-2 rounded-xl flex flex-col p-1 shadow-sm transition-all duration-300 ${bgClass} ${borderClass} ${highlightClass} ${cursorClass}`}
                >
                <div className="flex justify-between items-start opacity-60">
                    <span className={`font-bold text-xs md:text-sm ${hasGem ? 'text-white' : ''}`}>{num === 0 ? 'START' : num}</span>
                    {special && <span className="text-xs">{special.icon}</span>}
                </div>
                
                {hasGem && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <Gem className="text-yellow-400 gem-glow animate-bounce" size={24} fill="gold"/>
                    </div>
                )}

                <div className="flex-1 flex flex-wrap content-center justify-center gap-1 z-10">
                    {/* INFECTED NPC */}
                    {infected && infected.position === num && (
                        <div className="relative z-30 animate-pulse">
                             <div className="rounded-full border-2 border-green-900 bg-green-500 p-1 shadow-lg">
                                <Biohazard size={20} className="text-green-900"/>
                             </div>
                        </div>
                    )}
                    
                    {players.map(p => {
                        const teamColor = p.teamId !== undefined && TEAM_COLORS[p.teamId] ? TEAM_COLORS[p.teamId].border : 'border-white';
                        return (
                            <div key={p.id} className={`relative transition-all duration-300 ${p.finished || p.isDead ? 'opacity-50 scale-75' : 'hover:scale-125 hover:z-20'}`}>
                                <div className={`rounded-full border-2 ${teamColor} p-[1px]`}>
                                    <PlayerAvatar charId={p.characterId} size="sm" border={false} />
                                </div>
                                {p.skipTurns > 0 && <div className="absolute inset-0 bg-black/50 rounded-full flex items-center justify-center text-white text-[10px] font-bold">{p.skipTurns}</div>}
                                {p.finished && <div className="absolute -top-1 -right-1 bg-green-500 text-white rounded-full p-0.5"><Flag size={8}/></div>}
                                {p.isDead && <div className="absolute inset-0 bg-black/70 rounded-full flex items-center justify-center"><Skull className="text-white" size={14}/></div>}
                            </div>
                        );
                    })}
                </div>
                
                {isPendingTarget && (
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <Pointer className="text-yellow-600 animate-bounce w-8 h-8 drop-shadow-md fill-yellow-300" />
                    </div>
                )}

                {special && <div className={`text-[8px] md:text-[10px] text-center leading-tight truncate font-semibold opacity-80 ${hasGem ? 'text-white' : ''}`}>{special.name}</div>}
                </div>
            );
        };

        // --- MAIN APP COMPONENT ---

        function App() {
            const [user, setUser] = useState(null);
            const [view, setView] = useState('menu');
            const [roomCode, setRoomCode] = useState('');
            const [nickname, setNickname] = useState('');
            const [currentRoom, setCurrentRoom] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const [isMoving, setIsMoving] = useState(false); 
            const [lastRoll, setLastRoll] = useState(null);
            const [notif, setNotif] = useState(null); 
            const [selectedCellInfo, setSelectedCellInfo] = useState(null);
            const [useSpecialDie, setUseSpecialDie] = useState(false);
            const [directionChoice, setDirectionChoice] = useState(null); // { val: number }
            
            const [errorMsg, setErrorMsg] = useState(null);
            const [relayConfig, setRelayConfig] = useState({ teams: 2, size: 2 });

            const handleError = (error) => {
                console.error("Errore rilevato:", error);
                if (error.code === "permission-denied" || error.message.includes("permission")) {
                    setErrorMsg("Permesso negato: Controlla le regole del database Firebase o la configurazione.");
                } else if (error.code === "auth/configuration-not-found" || error.code === "auth/operation-not-allowed") {
                     setErrorMsg("Errore Autenticazione: Abilita 'Anonymous' in Firebase Console > Authentication.");
                } else {
                    setErrorMsg(error.message || "Si è verificato un errore sconosciuto.");
                }
                setTimeout(() => setErrorMsg(null), 8000); 
            };

            useEffect(() => {
                const initAuth = async () => {
                try {
                    await signInAnonymously(auth);
                } catch (e) {
                    handleError(e);
                }
                };
                initAuth();
                return onAuthStateChanged(auth, u => setUser(u));
            }, []);

            useEffect(() => {
                if (!roomCode || !user) return;
                const unsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), (snap) => {
                    if (snap.exists()) {
                        const data = snap.data();
                        setCurrentRoom(data);
                        if (data.status === 'playing' && view !== 'game') setView('game');
                        if (data.status === 'waiting' && view !== 'lobby') setView('lobby');
                    } else {
                        setView('menu');
                    }
                }, (err) => {
                    handleError(err);
                });
                return () => unsub();
            }, [roomCode, view, user]);

            useEffect(() => {
                if (currentRoom?.lastAction) {
                setNotif(currentRoom.lastAction);
                const t = setTimeout(() => setNotif(null), 3000);
                return () => clearTimeout(t);
                }
            }, [currentRoom?.lastAction]);

            // Host Logic for Infection
            useEffect(() => {
                if (currentRoom?.status === 'playing' && currentRoom.gameMode === 'infection' && currentRoom.hostId === user?.uid) {
                    if (currentRoom.currentTurn === 0 && currentRoom.round > 3 && !isMoving && !isRolling) {
                        // Check if infected needs to move (simple check: did we already move this round? stored in infected.lastMovedRound)
                        if (currentRoom.infectedNPC?.lastMovedRound < currentRoom.round) {
                            moveInfectedNPC();
                        }
                    }
                }
            }, [currentRoom, user, isMoving, isRolling]);

            const moveInfectedNPC = async () => {
                try {
                    const steps = [1, 2, 4, 6];
                    const roll = steps[Math.floor(Math.random() * steps.length)];
                    let npcPos = currentRoom.infectedNPC.position;
                    let newPos = npcPos + roll;
                    
                    let updates = {
                        'infectedNPC.position': newPos,
                        'infectedNPC.lastMovedRound': currentRoom.round,
                        lastAction: `L'INFETTO avanza di ${roll} passi!`
                    };

                    // Check collisions
                    let updatedPlayers = [...currentRoom.players];
                    let killCount = 0;
                    updatedPlayers = updatedPlayers.map(p => {
                        if (!p.isDead && !p.finished && p.position <= newPos) {
                            killCount++;
                            return { ...p, isDead: true, position: 0 };
                        }
                        return p;
                    });

                    if (killCount > 0) {
                        updates.players = updatedPlayers;
                        updates.lastAction += ` Ha preso ${killCount} sopravvissuti!`;
                        playSound('zombie');
                    } else {
                        playSound('step');
                    }

                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                } catch(e) { console.error(e); }
            };

            const createRoom = async (mode) => {
                if (!nickname || !user) return;
                try {
                    const code = Math.random().toString(36).substring(2, 7).toUpperCase();
                    const charId = Math.floor(Math.random() * ROSTER.length);
                    
                    let extraData = {};
                    if (mode === 'infection') {
                        extraData.infectedNPC = { position: 0, lastMovedRound: 0 };
                    }
                    if (mode === 'gem_hunt') {
                        // 3 random unique gems between 5 and 45
                        const gems = [];
                        while(gems.length < 3) {
                            const r = Math.floor(Math.random() * 40) + 5;
                            if(!gems.includes(r)) gems.push(r);
                        }
                        extraData.gemLocations = gems;
                    }

                    const startPos = mode === 'gem_hunt' ? (Math.random() > 0.5 ? 0 : 50) : 0;

                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', code), {
                        code,
                        hostId: user.uid,
                        gameMode: mode, 
                        teamConfig: mode === 'relay' ? relayConfig : null,
                        status: 'waiting',
                        currentTurn: 0,
                        round: 1, 
                        ...extraData,
                        players: [{
                            uid: user.uid,
                            name: nickname,
                            characterId: charId,
                            position: startPos,
                            skipTurns: 0,
                            finished: false,
                            isDead: false,
                            rank: 0,
                            isBot: false,
                            pendingTarget: null,
                            ...(mode === 'relay' ? { teamId: 0 } : {}),
                            ...(mode === 'gem_hunt' ? { collectedGems: [] } : {}),
                            pawnIdx: 0 
                        }],
                        lastAction: "Stanza Creata"
                    });
                    setRoomCode(code);
                    setView('lobby');
                } catch (e) {
                    handleError(e);
                }
            };

            const joinRoom = async (codeOverride) => {
                // FIXED: Use codeOverride directly to avoid async state issues
                const codeToJoin = codeOverride || roomCode;
                if (!nickname || !user || !codeToJoin) return;

                try {
                    const cleanCode = codeToJoin.toUpperCase().trim();
                    const ref = doc(db, 'artifacts', appId, 'public', 'data', 'matches', cleanCode);
                    const snap = await getDoc(ref);
                    
                    if (!snap.exists()) {
                        setErrorMsg(`Stanza ${cleanCode} non trovata!`);
                        return;
                    }
                    
                    const data = snap.data();
                    if (data.status !== 'waiting') {
                        setErrorMsg("La partita è già iniziata!");
                        return;
                    }

                    // Success! Update local state to match
                    setRoomCode(cleanCode);

                    if (data.players.some(p => p.uid === user.uid)) { setView('lobby'); return; }

                    const available = ROSTER.map(c=>c.id).filter(id => !data.players.some(p=>p.characterId === id));
                    const charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;

                    let bestTeam = 0;
                    if (data.gameMode === 'relay') {
                        const counts = Array(data.teamConfig.teams).fill(0);
                        data.players.forEach(p => counts[p.teamId]++);
                        bestTeam = counts.indexOf(Math.min(...counts));
                    }
                    
                    const startPos = data.gameMode === 'gem_hunt' ? (Math.random() > 0.5 ? 0 : 50) : 0;

                    const playerObj = {
                        uid: user.uid,
                        name: nickname,
                        characterId: charId,
                        position: startPos,
                        skipTurns: 0,
                        finished: false,
                        isDead: false,
                        rank: 0,
                        isBot: false,
                        pendingTarget: null,
                        pawnIdx: 0
                    };
                    if (data.gameMode === 'relay') playerObj.teamId = bestTeam;
                    if (data.gameMode === 'gem_hunt') playerObj.collectedGems = [];

                    await updateDoc(ref, {
                        players: arrayUnion(playerObj)
                    });
                    setView('lobby');
                } catch (e) {
                    handleError(e);
                }
            };

            const switchTeam = async (newTeamId) => {
                if (!currentRoom) return;
                try {
                    const updated = currentRoom.players.map(p => p.uid === user.uid ? { ...p, teamId: newTeamId } : p);
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
                } catch (e) {
                    handleError(e);
                }
            };

            const selectChar = async (charId) => {
                if (!currentRoom) return;
                try {
                    // Double check to ensure we don't overwrite if someone else took it
                    if (currentRoom.players.some(p => p.characterId === charId && p.uid !== user.uid)) return;
                    
                    // Force update only for current user
                    const updated = currentRoom.players.map(p => p.uid === user.uid ? { ...p, characterId: charId } : p);
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: updated });
                } catch (e) {
                    handleError(e);
                }
            };

            const addBot = async () => {
                if (!currentRoom) return;
                try {
                    const available = ROSTER.map(c=>c.id).filter(id => !currentRoom.players.some(p=>p.characterId === id));
                    const charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;
                    const botId = `bot_${Date.now()}`;
                    
                    let bestTeam = 0;
                    if (currentRoom.gameMode === 'relay') {
                        const counts = Array(currentRoom.teamConfig.teams).fill(0);
                        currentRoom.players.forEach(p => counts[p.teamId]++);
                        bestTeam = counts.indexOf(Math.min(...counts));
                    }

                    const startPos = currentRoom.gameMode === 'gem_hunt' ? (Math.random() > 0.5 ? 0 : 50) : 0;

                    const newBot = {
                        uid: botId,
                        name: `BOT ${ROSTER[charId].name.split(' ')[0]}`,
                        characterId: charId,
                        position: startPos,
                        skipTurns: 0,
                        finished: false,
                        isDead: false,
                        rank: 0,
                        isBot: true,
                        pendingTarget: null,
                        pawnIdx: 0
                    };
                    if (currentRoom.gameMode === 'relay') newBot.teamId = bestTeam;
                    if (currentRoom.gameMode === 'gem_hunt') newBot.collectedGems = [];
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                        players: [...currentRoom.players, newBot]
                    });
                } catch (e) {
                    handleError(e);
                }
            };

            const startGame = async () => {
                try {
                    let gamePlayers = [...currentRoom.players];

                    // Relay Expansion Logic
                    if (currentRoom.gameMode === 'relay') {
                        // ... (same as before) ...
                         const expandedPlayers = [];
                        const teamSize = currentRoom.teamConfig.size;
                        const numTeams = currentRoom.teamConfig.teams;

                        const teamUsers = Array.from({ length: numTeams }, () => []);
                        gamePlayers.forEach(p => {
                            if (p.teamId < numTeams) teamUsers[p.teamId].push(p);
                        });

                        for (let t = 0; t < numTeams; t++) {
                            const users = teamUsers[t];
                            if (users.length === 0) continue; 

                            for (let slot = 0; slot < teamSize; slot++) {
                                const userIndex = slot % users.length;
                                const baseUser = users[userIndex];

                                let charId = baseUser.characterId;
                                if (slot >= users.length) {
                                    const usedChars = new Set([...gamePlayers.map(p => p.characterId), ...expandedPlayers.map(p => p.characterId)]);
                                    const available = ROSTER.map(c => c.id).filter(id => !usedChars.has(id));
                                    charId = available.length > 0 ? available[Math.floor(Math.random() * available.length)] : 0;
                                }

                                expandedPlayers.push({
                                    ...baseUser,
                                    id: `${baseUser.uid}_slot${slot}`, 
                                    pawnIdx: slot,
                                    characterId: charId,
                                    position: 0,
                                    finished: false,
                                    skipTurns: 0,
                                    pendingTarget: null
                                });
                            }
                        }
                        
                        gamePlayers = [];
                        for(let slot=0; slot<teamSize; slot++) {
                            for(let t=0; t<numTeams; t++) {
                                const pawn = expandedPlayers.find(p => p.teamId === t && p.pawnIdx === slot);
                                if(pawn) gamePlayers.push(pawn);
                            }
                        }
                    } else {
                        gamePlayers = gamePlayers.map(p => ({...p, id: p.uid}));
                    }

                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { 
                        status: 'playing', 
                        lastAction: currentRoom.gameMode === 'gem_hunt' ? "Caccia alle Gemme iniziata!" : (currentRoom.gameMode === 'infection' ? "Sopravvivete all'Infetto!" : "La staffetta ha inizio!"),
                        players: gamePlayers,
                        currentTurn: 0
                    });
                } catch (e) {
                    handleError(e);
                }
            };

            const isPawnLocked = (pawn, allPlayers) => {
                if (currentRoom.gameMode !== 'relay') return false;
                if (pawn.pawnIdx === 0) return false; 
                
                const teammate = allPlayers.find(p => p.teamId === pawn.teamId && p.pawnIdx === pawn.pawnIdx - 1);
                return teammate && !teammate.finished;
            };

            const checkTeamWin = (players, teamId) => {
                const teamPawns = players.filter(p => p.teamId === teamId);
                return teamPawns.every(p => p.finished);
            };

            const executeMove = async (playerId, targetPos) => {
                if (isMoving) return;
                setIsMoving(true);
                playSound('click');
                setDirectionChoice(null); // Clear pending choice

                try {
                    const currentPlayer = currentRoom.players[currentRoom.currentTurn];
                    if (currentPlayer.uid !== playerId && !currentPlayer.isBot) { setIsMoving(false); return; }

                    const pIndex = currentRoom.currentTurn;
                    const player = currentRoom.players[pIndex];
                    const currentPos = player.position;
                    const config = currentRoom.gameMode === 'elimination' ? ELIM_MAP : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP : CLASSIC_MAP);

                    const steps = [];
                    const direction = targetPos >= currentPos ? 1 : -1;
                    const dist = Math.abs(targetPos - currentPos); 
                    
                    for (let i = 1; i <= dist; i++) {
                        steps.push(currentPos + (i * direction));
                    }
                    
                    let tempPlayers = [...currentRoom.players];
                    let gemsCollectedThisTurn = [...(player.collectedGems || [])];
                    let tempGemLocations = [...(currentRoom.gemLocations || [])];

                    for (let stepPos of steps) {
                        tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: stepPos };
                        
                        // Gem Hunt Collection Logic (On passing or landing)
                        if (currentRoom.gameMode === 'gem_hunt' && tempGemLocations.includes(stepPos)) {
                             if (!gemsCollectedThisTurn.includes(stepPos)) {
                                 gemsCollectedThisTurn.push(stepPos);
                                 tempPlayers[pIndex].collectedGems = gemsCollectedThisTurn;
                                 
                                 // Remove & Respawn
                                 tempGemLocations = tempGemLocations.filter(g => g !== stepPos);
                                 let newGem = -1;
                                 while(newGem === -1 || tempGemLocations.includes(newGem) || newGem === stepPos || newGem === 0 || newGem === 50) {
                                     newGem = Math.floor(Math.random() * 41) + 5; 
                                 }
                                 tempGemLocations.push(newGem);
                                 
                                 playSound('gem');
                             }
                        }
                        
                        let intermediateUpdate = { players: tempPlayers };
                        if (currentRoom.gameMode === 'gem_hunt') intermediateUpdate.gemLocations = tempGemLocations;

                        await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), intermediateUpdate);
                        if (!tempGemLocations.includes(stepPos)) playSound('step'); // Don't double sound
                        await sleep(250); 
                    }

                    let finalPos = targetPos;
                    let log = `${player.name} (${player.pawnIdx + 1}°) è alla ${finalPos}.`;
                    let special = config.specials[finalPos];
                    let extraTurns = 0;

                    if (special) {
                        log += ` ${special.name}!`; 
                        
                        if (special.type === 'BOOST') {
                            await sleep(500);
                            finalPos += special.val; 
                            // Bounds check
                            if (finalPos < 0) finalPos = 0;
                            if (finalPos > config.max) finalPos = config.max;

                            tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: finalPos };
                             // Check gem on boost landing
                             if (currentRoom.gameMode === 'gem_hunt' && tempGemLocations.includes(finalPos)) {
                                if (!gemsCollectedThisTurn.includes(finalPos)) {
                                    gemsCollectedThisTurn.push(finalPos);
                                    tempPlayers[pIndex].collectedGems = gemsCollectedThisTurn;
                                    
                                     // Remove & Respawn
                                    tempGemLocations = tempGemLocations.filter(g => g !== finalPos);
                                    let newGem = -1;
                                    while(newGem === -1 || tempGemLocations.includes(newGem) || newGem === finalPos || newGem === 0 || newGem === 50) {
                                        newGem = Math.floor(Math.random() * 41) + 5; 
                                    }
                                    tempGemLocations.push(newGem);
                                    
                                    playSound('gem');
                                }
                            }

                            let boostUpdate = { players: tempPlayers };
                            if (currentRoom.gameMode === 'gem_hunt') boostUpdate.gemLocations = tempGemLocations;

                            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), boostUpdate);
                            playSound('step');
                        }
                        else if (special.type === 'JUMP' || special.type === 'BACK' || special.type === 'RESTART') {
                            await sleep(800);
                            finalPos = special.val || 0;
                            tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: finalPos };
                            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers });
                            playSound('step');
                        }
                        else if (special.type === 'DOUBLE') { 
                            await sleep(800);
                            const moveAmt = dist; 
                            log += ` Avanza ancora di ${moveAmt}!`;
                            
                            finalPos = finalPos + (moveAmt * direction); 
                            if (finalPos > config.max) finalPos = config.max;
                            if (finalPos < 0) finalPos = 0;

                            tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: finalPos };
                            
                            if (currentRoom.gameMode === 'gem_hunt' && tempGemLocations.includes(finalPos)) {
                                if (!gemsCollectedThisTurn.includes(finalPos)) {
                                    gemsCollectedThisTurn.push(finalPos);
                                    tempPlayers[pIndex].collectedGems = gemsCollectedThisTurn;
                                    
                                     // Remove & Respawn
                                    tempGemLocations = tempGemLocations.filter(g => g !== finalPos);
                                    let newGem = -1;
                                    while(newGem === -1 || tempGemLocations.includes(newGem) || newGem === finalPos || newGem === 0 || newGem === 50) {
                                        newGem = Math.floor(Math.random() * 41) + 5; 
                                    }
                                    tempGemLocations.push(newGem);
                                    
                                    playSound('gem');
                                }
                            }
                            
                            let doubleUpdate = { players: tempPlayers };
                            if (currentRoom.gameMode === 'gem_hunt') doubleUpdate.gemLocations = tempGemLocations;

                            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), doubleUpdate);
                            playSound('step');
                        }
                        else if (special.type === 'TAIL') {
                            await sleep(800);
                            const sortedByPos = [...tempPlayers].filter(p => !p.isDead).sort((a,b) => b.position - a.position);
                            const myRankIdx = sortedByPos.findIndex(p => p.id === player.id);
                            if (myRankIdx > 0) {
                                const targetPlayer = sortedByPos[myRankIdx - 1]; 
                                log += ` Scatta dietro a ${targetPlayer.name}!`;
                                finalPos = Math.max(0, targetPlayer.position - 1);
                            }
                            tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: finalPos };
                            await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers });
                            playSound('step');
                        }
                        else if (special.type === 'TELEPORT') {
                            await sleep(800);
                            const others = tempPlayers.filter(p => p.id !== player.id && !p.isDead && !p.finished);
                            if (others.length > 0) {
                                const targetP = others[Math.floor(Math.random() * others.length)];
                                log += ` Scambio dimensionale con ${targetP.name}!`;
                                finalPos = targetP.position;
                                tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: finalPos };
                                await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { players: tempPlayers });
                                playSound('teleport');
                            }
                        }
                        if (special.type === 'WAIT') extraTurns = special.turns;
                    }

                    tempPlayers[pIndex] = { ...tempPlayers[pIndex], position: finalPos, skipTurns: extraTurns, pendingTarget: null };

                    let updates = { players: tempPlayers, lastAction: log };
                    if (currentRoom.gameMode === 'gem_hunt') updates.gemLocations = tempGemLocations; // Final sync check

                    let hasFinished = false;

                    if (currentRoom.gameMode === 'gem_hunt') {
                        // Win condition: 3 gems collected
                        if (tempPlayers[pIndex].collectedGems.length >= 3) {
                            tempPlayers[pIndex].finished = true;
                            log += " HA RACCOLTO TUTTE LE GEMME!";
                            playSound('win');
                            hasFinished = true;
                        }
                    } else {
                        // Standard win condition
                         if (finalPos === config.max) {
                            tempPlayers[pIndex].finished = true;
                            log += " TRAGUARDO!";
                            playSound('win');
                            hasFinished = true;
                            // RELAY UNLOCK LOGIC notification
                            if (currentRoom.gameMode === 'relay') {
                                const nextTeammate = tempPlayers.find(p => p.teamId === player.teamId && p.pawnIdx === player.pawnIdx + 1);
                                if (nextTeammate) log += ` Parte il compagno ${nextTeammate.name}!`;
                            }
                        }
                    }

                    // CHECK WIN CONDITIONS
                    if (currentRoom.gameMode === 'gem_hunt') {
                        const totalPlayers = tempPlayers.length;
                        const finishedCount = tempPlayers.filter(p => p.finished).length;
                        
                        // Game ends when Penultimate wins (only 1 loser remains)
                        // Or if 1 player, when he wins.
                        if (totalPlayers > 1 && finishedCount >= totalPlayers - 1) {
                            updates.status = 'finished';
                            updates.winner = "TUTTI SALVI (tranne uno!)"; 
                            updates.lastAction = "CACCIA ALLE GEMME CONCLUSA!";
                        } else if (totalPlayers === 1 && finishedCount === 1) {
                             updates.status = 'finished';
                             updates.winner = player.name;
                        } else {
                             updates.currentTurn = getNextTurn(tempPlayers, currentRoom.currentTurn);
                        }

                    } else if (currentRoom.gameMode === 'relay') {
                        if (checkTeamWin(tempPlayers, player.teamId)) {
                            updates.status = 'finished';
                            updates.winner = `TEAM ${TEAM_COLORS[player.teamId].name}`; 
                            updates.lastAction = `IL TEAM ${TEAM_COLORS[player.teamId].name} VINCE LA STAFFETTA!`;
                        } else {
                            updates.currentTurn = getNextTurn(tempPlayers, currentRoom.currentTurn);
                        }
                    } else if (currentRoom.gameMode === 'elimination') {
                        const living = tempPlayers.filter(p => !p.isDead);
                        const finished = living.filter(p => p.finished);
                        if (finished.length === living.length - 1 && living.length > 1) {
                            const loser = living.find(p => !p.finished);
                            const loserIndex = tempPlayers.findIndex(p => p.id === loser.id);
                            tempPlayers[loserIndex].isDead = true;
                            tempPlayers[loserIndex].position = 0; 
                            tempPlayers.forEach(p => { if (!p.isDead) { p.position = 0; p.finished = false; p.skipTurns = 0; p.pendingTarget = null; } });
                            updates.players = tempPlayers;
                            updates.round = currentRoom.round + 1;
                            updates.lastAction = `${loser.name} ELIMINATO! Inizia il Round ${updates.round}!`;
                            playSound('eliminated');
                            updates.currentTurn = 0;
                        } else if (living.length === 1 && living[0].finished) {
                            updates.status = 'finished';
                            updates.winner = living[0].name;
                            updates.lastAction = `VITTORIA PER ${living[0].name}!`;
                        } else {
                            updates.currentTurn = getNextTurn(tempPlayers, currentRoom.currentTurn);
                        }
                    } else if (currentRoom.gameMode === 'infection') {
                        // Classic win but watch out for zombies
                        if (finalPos === config.max) {
                            updates.status = 'finished';
                            updates.winner = player.name;
                        } else {
                            // Check round increment for infection movement
                            const nextTurn = getNextTurn(tempPlayers, currentRoom.currentTurn);
                            updates.currentTurn = nextTurn;
                            if (nextTurn === 0) {
                                updates.round = currentRoom.round + 1;
                            }
                        }
                    }
                     else {
                        if (finalPos === config.max) {
                            updates.status = 'finished';
                            updates.winner = player.name;
                        } else {
                            updates.currentTurn = getNextTurn(tempPlayers, currentRoom.currentTurn);
                        }
                    }

                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), updates);
                } catch (e) {
                    handleError(e);
                }
                setIsMoving(false);
            };

            const confirmGemMove = async (dir) => {
                 // Triggered from UI in Gem Hunt mode
                 if (!directionChoice) return;
                 const player = currentRoom.players[currentRoom.currentTurn];
                 
                 const config = GEM_MAP;
                 let newPos = player.position + (directionChoice.val * dir);
                 if (newPos > config.max) newPos = config.max;
                 if (newPos < 0) newPos = 0;
                 if (directionChoice.val === 0) newPos = player.position;

                 const updated = [...currentRoom.players];
                 updated[currentRoom.currentTurn] = { ...player, pendingTarget: newPos };

                 await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                    players: updated,
                    lastAction: `${player.name} sceglie di andare ${dir > 0 ? 'AVANTI' : 'INDIETRO'}!`
                 });
                 setDirectionChoice(null);
            };

            const handleRoll = async () => {
                if (isRolling || isMoving || !currentRoom) return;
                const player = currentRoom.players[currentRoom.currentTurn];
                
                if (player.uid !== user.uid && !player.isBot) return;
                
                try {
                    if (isPawnLocked(player, currentRoom.players)) {
                        const next = getNextTurn(currentRoom.players, currentRoom.currentTurn);
                        await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                            currentTurn: next,
                            lastAction: `${player.name} deve aspettare il compagno!`
                        });
                        return;
                    }

                    if (player.skipTurns > 0) {
                        const updated = [...currentRoom.players];
                        updated[currentRoom.currentTurn].skipTurns -= 1;
                        const next = getNextTurn(updated, currentRoom.currentTurn);
                        await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                            players: updated,
                            currentTurn: next,
                            lastAction: `${player.name} salta il turno.`
                        });
                        return;
                    }

                    setIsRolling(true);
                    playSound('step');
                    
                    const isSpecial = useSpecialDie && !player.isBot;
                    // SAFETY: default to charId 0 if invalid
                    const charId = (player.characterId >= 0 && player.characterId < ROSTER.length) ? player.characterId : 0;
                    const specialDice = ROSTER[charId].dice;
                    
                    for(let i=0; i<10; i++) {
                        const animVal = isSpecial ? specialDice.vals[Math.floor(Math.random()*6)] : Math.floor(Math.random()*6)+1;
                        setLastRoll(currentRoom.gameMode === 'gem_hunt' ? Math.abs(animVal) : animVal);
                        await sleep(50);
                    }
                    
                    let val = isSpecial ? specialDice.vals[Math.floor(Math.random() * 6)] : Math.floor(Math.random() * 6) + 1;
                    
                    // GEM HUNT MODIFIER
                    if (currentRoom.gameMode === 'gem_hunt') val = Math.abs(val);

                    setLastRoll(val);
                    await sleep(200);

                    if (currentRoom.gameMode === 'gem_hunt' && val !== 0 && !player.isBot) {
                        // User needs to choose direction
                         setDirectionChoice({ val });
                         setIsRolling(false);
                         return;
                    }

                    // Bot logic or linear modes
                    const config = currentRoom.gameMode === 'elimination' ? ELIM_MAP : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP : CLASSIC_MAP);
                    
                    // Default direction forward for bots or non-gem modes
                    // If gem hunt bot, random direction? Or smart? Let's say random for now.
                    let dir = 1;
                    if (currentRoom.gameMode === 'gem_hunt' && player.isBot) {
                         dir = Math.random() > 0.5 ? 1 : -1;
                    }

                    let newPos = player.position + (val * dir);
                    
                    // No bounce logic
                    if (newPos > config.max) newPos = config.max; 
                    if (newPos < 0) newPos = 0;
                    if (val === 0) newPos = player.position;
                    
                    const updated = [...currentRoom.players];
                    updated[currentRoom.currentTurn] = { ...player, pendingTarget: newPos };
                    
                    await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), {
                        players: updated,
                        lastAction: `${player.name} (${player.teamId !== undefined ? `T${player.teamId+1}` : ''}): ${val}! Vai alla ${newPos}!`
                    });
                } catch (e) {
                    handleError(e);
                }
                setIsRolling(false);
            };

            const getNextTurn = (players, currentIdx) => {
                let next = (currentIdx + 1) % players.length;
                let loop = 0;
                while(
                    loop < players.length * 2 && 
                    (players[next].isDead || players[next].finished || players[next].skipTurns > 0 || isPawnLocked(players[next], players))
                ) {
                    if (players[next].skipTurns > 0) break; 
                    next = (next + 1) % players.length;
                    loop++;
                }
                return next;
            };

            useEffect(() => {
                if (currentRoom?.status === 'playing') {
                    // SAFETY: check if player exists
                    if (!currentRoom.players || !currentRoom.players[currentRoom.currentTurn]) return;

                    const p = currentRoom.players[currentRoom.currentTurn];
                    if (p.isBot && currentRoom.hostId === user?.uid && !isRolling && !isMoving) {
                        if (p.pendingTarget === null) {
                            if (isPawnLocked(p, currentRoom.players)) {
                                const next = getNextTurn(currentRoom.players, currentRoom.currentTurn);
                                updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'matches', roomCode), { currentTurn: next })
                                .catch(handleError);
                            } else if (!directionChoice) { // Ensure bot doesn't hang if I add decision logic later
                                const t = setTimeout(() => handleRoll(), 1500);
                                return () => clearTimeout(t);
                            }
                        } else {
                            const t = setTimeout(() => executeMove(p.uid, p.pendingTarget), 1500);
                            return () => clearTimeout(t);
                        }
                    }
                }
            }, [currentRoom, isRolling, isMoving, user, directionChoice]);

            if (!user) return <div className="h-screen flex items-center justify-center bg-slate-900 text-white">Caricamento...</div>;

            // SAFETY: prepare current player helper
            const currentPlayer = (currentRoom && currentRoom.players && currentRoom.players[currentRoom.currentTurn]) 
                ? currentRoom.players[currentRoom.currentTurn] 
                : null;
            
            const currentPlayerChar = currentPlayer 
                ? ((currentPlayer.characterId >= 0 && currentPlayer.characterId < ROSTER.length) ? ROSTER[currentPlayer.characterId] : ROSTER[0]) 
                : ROSTER[0];

            return (
                <div className="min-h-screen bg-slate-50 text-slate-800 font-sans flex flex-col relative">
                
                {/* MODAL INFO CASELLA */}
                {selectedCellInfo && (
                    <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-black/60 backdrop-blur-sm animate-in fade-in">
                        <div className="bg-white rounded-2xl p-6 max-w-sm w-full shadow-2xl relative border-4 border-indigo-200">
                            <button onClick={()=>setSelectedCellInfo(null)} className="absolute top-2 right-2 p-1 rounded-full hover:bg-slate-100"><X size={20}/></button>
                            <div className="flex flex-col items-center text-center gap-3">
                                <div className="p-4 bg-indigo-50 rounded-full text-indigo-600 mb-2 scale-125">{selectedCellInfo.icon}</div>
                                <h3 className="text-2xl font-black text-indigo-900">{selectedCellInfo.name}</h3>
                                <p className="text-lg text-slate-600 font-medium leading-relaxed">{selectedCellInfo.desc}</p>
                            </div>
                        </div>
                    </div>
                )}
                
                {/* ERROR BANNER */}
                {errorMsg && (
                    <div className="fixed top-0 left-0 w-full bg-red-600 text-white text-center p-2 z-[100] font-bold flex items-center justify-center gap-2">
                        <AlertCircle /> {errorMsg}
                    </div>
                )}

                {/* NAVBAR */}
                <div className="bg-indigo-900 text-white p-3 flex justify-between items-center shadow-lg z-50">
                    <div className="font-black text-xl flex items-center gap-2"><ArrowRight className="text-yellow-400"/> MULTIVERSE RUN</div>
                    {currentRoom && <div className="font-mono bg-indigo-800 px-2 py-1 rounded text-xs flex items-center gap-2"><span>ROOM: {currentRoom.code}</span> {currentRoom.gameMode === 'relay' && <span className="bg-yellow-500 text-black px-1 rounded text-[10px] font-bold">STAFFETTA</span>}</div>}
                    {view !== 'menu' && <button onClick={() => { setView('menu'); setRoomCode(''); }}><LogOut size={20}/></button>}
                </div>

                <div className={`fixed top-16 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-2 rounded-full shadow-2xl transition-all duration-300 z-50 font-bold border border-slate-600 ${notif ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-10 pointer-events-none'}`}>
                    {notif}
                </div>

                <div className="flex-1 flex overflow-hidden">
                    <div className="flex-1 overflow-y-auto p-4 flex flex-col items-center">
                        
                        {view === 'menu' && (
                        <div className="max-w-md w-full mt-10 space-y-6">
                            <div className="text-center">
                                <h1 className="text-4xl font-black text-indigo-900 mb-2">SCEGLI IL TUO DESTINO</h1>
                                <p className="text-slate-500">Corsa, Sopravvivenza, Squadra o Caos?</p>
                            </div>
                            
                            <input type="text" placeholder="Il tuo Nickname" className="w-full p-4 text-center text-xl font-bold rounded-xl border-2 border-slate-300 focus:border-indigo-500 outline-none" value={nickname} onChange={e=>setNickname(e.target.value)} />

                            <div className="grid grid-cols-2 gap-2">
                                <button onClick={() => createRoom('classic')} disabled={!nickname} className="h-24 bg-gradient-to-br from-green-400 to-emerald-600 rounded-xl text-white font-black text-sm shadow-xl hover:scale-105 transition-all flex flex-col items-center justify-center gap-1">
                                    <Flag size={24}/> CLASSICA
                                </button>
                                <button onClick={() => createRoom('elimination')} disabled={!nickname} className="h-24 bg-gradient-to-br from-red-500 to-orange-600 rounded-xl text-white font-black text-sm shadow-xl hover:scale-105 transition-all flex flex-col items-center justify-center gap-1">
                                    <Skull size={24}/> ELIMINAZIONE
                                </button>
                                <button onClick={() => createRoom('infection')} disabled={!nickname} className="h-24 bg-gradient-to-br from-lime-600 to-green-800 rounded-xl text-white font-black text-sm shadow-xl hover:scale-105 transition-all flex flex-col items-center justify-center gap-1">
                                    <Biohazard size={24}/> INFEZIONE
                                </button>
                                <button onClick={() => createRoom('gem_hunt')} disabled={!nickname} className="h-24 bg-gradient-to-br from-purple-500 to-indigo-600 rounded-xl text-white font-black text-sm shadow-xl hover:scale-105 transition-all flex flex-col items-center justify-center gap-1">
                                    <Gem size={24}/> GEMME
                                </button>
                            </div>
                             <button onClick={() => {
                                    if(nickname) setView('relay_setup');
                                }} disabled={!nickname} className="w-full py-3 bg-gradient-to-br from-blue-400 to-indigo-600 rounded-xl text-white font-black text-lg shadow-xl hover:scale-105 transition-all flex flex-col items-center justify-center gap-1">
                                    <Users size={24}/> STAFFETTA
                                </button>

                            <div className="flex gap-2">
                                <input id="codeIn" type="text" placeholder="CODICE" className="flex-1 p-3 rounded-xl border-2 font-mono text-center uppercase font-bold"/>
                                <button onClick={() => { 
                                    const val = document.getElementById('codeIn').value.toUpperCase().trim();
                                    joinRoom(val); 
                                }} disabled={!nickname} className="px-6 bg-slate-800 text-white font-bold rounded-xl">ENTRA</button>
                            </div>
                        </div>
                        )}

                        {/* ... (resto del codice simile per relay_setup e lobby) ... */}
                        {view === 'relay_setup' && (
                            <div className="max-w-md w-full mt-10 space-y-6 bg-white p-6 rounded-2xl shadow-xl">
                                <h2 className="text-2xl font-black text-center text-indigo-900">CONFIGURA STAFFETTA</h2>
                                
                                <div>
                                    <label className="block font-bold text-slate-500 mb-2">Numero di Team</label>
                                    <div className="flex gap-2">
                                        {[2,3,4].map(n => (
                                            <button key={n} onClick={() => setRelayConfig({...relayConfig, teams: n})} className={`flex-1 py-3 rounded-lg font-bold border-2 ${relayConfig.teams === n ? 'bg-indigo-600 text-white border-indigo-600' : 'border-slate-200'}`}>{n}</button>
                                        ))}
                                    </div>
                                </div>
                                
                                <div>
                                    <label className="block font-bold text-slate-500 mb-2">Membri per Team</label>
                                    <div className="flex gap-2">
                                        {[2,3,4].map(n => (
                                            <button key={n} onClick={() => setRelayConfig({...relayConfig, size: n})} className={`flex-1 py-3 rounded-lg font-bold border-2 ${relayConfig.size === n ? 'bg-indigo-600 text-white border-indigo-600' : 'border-slate-200'}`}>{n}</button>
                                        ))}
                                    </div>
                                </div>

                                <button onClick={() => createRoom('relay')} className="w-full py-4 bg-green-500 text-white font-black text-xl rounded-xl shadow-lg hover:bg-green-600">CREA STANZA</button>
                                <button onClick={() => setView('menu')} className="w-full py-2 text-slate-400 font-bold">Annulla</button>
                            </div>
                        )}

                        {view === 'lobby' && currentRoom && (
                        <div className="w-full max-w-6xl space-y-6">
                            <div className="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 flex flex-col md:flex-row justify-between items-center gap-4">
                                <div>
                                    <h2 className="text-2xl font-black text-indigo-900 flex items-center gap-2">
                                        LOBBY: {currentRoom.gameMode.toUpperCase().replace('_', ' ')}
                                    </h2>
                                    {currentRoom.gameMode === 'relay' && (
                                        <p className="text-slate-500 font-medium">Config: {currentRoom.teamConfig.teams} Squadre da {currentRoom.teamConfig.size} Membri</p>
                                    )}
                                </div>
                                {currentRoom.hostId === user.uid && (
                                <div className="flex gap-2">
                                    <button onClick={addBot} className="bg-slate-200 px-4 py-2 rounded-lg font-bold hover:bg-slate-300">AGGIUNGI BOT</button>
                                    <button onClick={startGame} className="bg-green-500 text-white px-8 py-2 rounded-lg font-bold shadow-lg hover:bg-green-600 hover:scale-105 transition-all">START</button>
                                </div>
                                )}
                            </div>

                            {/* RELAY TEAM SELECTOR */}
                            {currentRoom.gameMode === 'relay' && (
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    {Array.from({length: currentRoom.teamConfig.teams}).map((_, tIdx) => (
                                        <div key={tIdx} className={`rounded-xl border-4 ${TEAM_COLORS[tIdx].border} bg-white overflow-hidden flex flex-col`}>
                                            <div className={`${TEAM_COLORS[tIdx].bg} text-white p-2 font-black text-center flex justify-between items-center`}>
                                                <span>TEAM {tIdx + 1}</span>
                                                {currentRoom.players.find(p=>p.uid===user.uid)?.teamId !== tIdx && (
                                                    <button onClick={() => switchTeam(tIdx)} className="bg-white/20 hover:bg-white/40 px-2 py-0.5 rounded text-xs">UNISCITI</button>
                                                )}
                                            </div>
                                            <div className="p-2 space-y-2 flex-1 min-h-[100px]">
                                                {currentRoom.players.filter(p => p.teamId === tIdx).map(p => (
                                                    <div key={p.uid} className="flex items-center gap-2 bg-slate-50 p-2 rounded-lg border">
                                                        <PlayerAvatar charId={p.characterId} size="sm" border={false}/>
                                                        <span className="font-bold text-sm truncate">{p.name}</span>
                                                    </div>
                                                ))}
                                                {currentRoom.players.filter(p => p.teamId === tIdx).length === 0 && (
                                                    <div className="text-center text-slate-300 text-xs italic py-4">Nessun giocatore</div>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {/* CHARACTER SELECTOR */}
                            <div className="w-full text-center text-slate-400 font-bold text-sm tracking-widest uppercase mb-2">Clicca per cambiare</div>
                            <div className="grid grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-3">
                                {ROSTER.map(c => {
                                    const taken = currentRoom.players.some(p => p.characterId === c.id);
                                    const mine = currentRoom.players.find(p => p.uid === user.uid)?.characterId === c.id;
                                    return (
                                    <button key={c.id} onClick={() => selectChar(c.id)} disabled={taken && !mine} className={`relative group aspect-[3/4] rounded-xl overflow-hidden transition-all bg-slate-100 flex flex-col items-center ${mine ? 'ring-4 ring-indigo-500 scale-105 z-10' : 'hover:scale-105 hover:ring-2 hover:ring-indigo-300'} ${taken && !mine ? 'grayscale opacity-50' : ''}`}>
                                        <div className="flex-1 w-full overflow-hidden">
                                            <img src={c.img} className="w-full h-full object-cover"/>
                                        </div>
                                        <div className={`w-full text-[8px] md:text-[10px] p-1 font-bold text-center text-white ${c.dice.color}`}>
                                            {c.dice.name}
                                        </div>
                                        {mine && <div className="absolute top-1 right-1 bg-indigo-500 text-white p-0.5 rounded-full"><ArrowDown size={12}/></div>}
                                    </button>
                                    )
                                })}
                            </div>
                            
                            {/* CLASSIC LOBBY LIST (Only if not relay, or simplified view) */}
                            {currentRoom.gameMode !== 'relay' && (
                                <div className="flex flex-wrap gap-2">
                                    {currentRoom.players.map(p => (
                                    <div key={p.uid} className="flex items-center gap-2 bg-white px-3 py-1 rounded-full border shadow-sm">
                                        <PlayerAvatar charId={p.characterId} size="sm" border={false}/>
                                        <div className="flex flex-col">
                                            <span className="font-bold text-sm leading-none">{p.name}</span>
                                            <span className={`text-[10px] font-bold text-slate-500`}>Wait...</span>
                                        </div>
                                    </div>
                                    ))}
                                </div>
                            )}
                        </div>
                        )}

                        {view === 'game' && currentRoom && currentPlayer && (
                        <div className="w-full max-w-5xl flex flex-col gap-4">
                            
                            {/* GAME HEADER */}
                            <div className="flex items-center justify-between bg-white p-3 rounded-xl shadow-sm border border-slate-200 sticky top-0 z-30">
                                <div className="flex items-center gap-3">
                                    <div className="text-center">
                                    <div className="text-[10px] text-slate-400 font-bold uppercase">TURNO DI</div>
                                    <div className="font-black text-indigo-900 leading-none">
                                        {currentPlayer.name} 
                                        {currentPlayer.teamId !== undefined && TEAM_COLORS[currentPlayer.teamId] && (
                                            <span className={`ml-1 px-1 rounded text-white text-[10px] ${TEAM_COLORS[currentPlayer.teamId].bg}`}>
                                                T{currentPlayer.teamId + 1}
                                            </span>
                                        )}
                                    </div>
                                    </div>
                                    <PlayerAvatar charId={currentPlayer.characterId}/>
                                </div>
                                
                                <div className="flex flex-col items-end">
                                    {currentRoom.gameMode === 'elimination' && (
                                        <div className="flex items-center gap-2 text-orange-600 font-black"><Flame size={18}/> ROUND {currentRoom.round}</div>
                                    )}
                                    {currentRoom.gameMode === 'infection' && (
                                        <div className="flex items-center gap-2 text-lime-600 font-black"><Biohazard size={18}/> ROUND {currentRoom.round}</div>
                                    )}
                                     {currentRoom.gameMode === 'gem_hunt' && (
                                        <div className="flex items-center gap-2 text-purple-600 font-black"><Gem size={18}/> CACCIA</div>
                                    )}
                                    {currentRoom.gameMode === 'relay' && (
                                        <div className="flex items-center gap-2 text-blue-600 font-black"><Users size={18}/> STAFFETTA</div>
                                    )}
                                    <div className="text-xs text-slate-400 font-bold">
                                        {currentRoom.gameMode === 'classic' ? 'RAGGIUNGI IL 60!' : currentRoom.gameMode === 'gem_hunt' ? 'PRENDI 3 GEMME!' : 'TUTTI AL TRAGUARDO!'}
                                    </div>
                                </div>
                            </div>

                            {/* BOARD */}
                            <div className="grid grid-cols-5 md:grid-cols-8 lg:grid-cols-10 gap-1.5 p-2 bg-slate-200/50 rounded-xl">
                                {Array.from({ length: (currentRoom.gameMode === 'elimination' ? ELIM_MAP.max : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP.max : CLASSIC_MAP.max)) + 1 }).map((_, i) => {
                                    const config = currentRoom.gameMode === 'elimination' ? ELIM_MAP : (currentRoom.gameMode === 'gem_hunt' ? GEM_MAP : CLASSIC_MAP);
                                    const playersHere = currentRoom.players.filter(p => p.position === i && !p.isDead);
                                    // Safety: currentPlayer is defined by parent check
                                    const isPendingTarget = currentPlayer.uid === user.uid && currentPlayer.pendingTarget === i;
                                    
                                    return <BoardCell key={i} num={i} players={playersHere} special={config.specials[i]} 
                                            isElimination={currentRoom.gameMode === 'elimination'}
                                            isPendingTarget={isPendingTarget}
                                            onCellClick={() => executeMove(user.uid, i)}
                                            onInfoClick={(spec) => setSelectedCellInfo(spec)}
                                            gems={currentRoom.gemLocations}
                                            infected={currentRoom.infectedNPC}
                                        />
                                })}
                            </div>

                            {/* CONTROLS */}
                            <div className="fixed bottom-6 left-1/2 -translate-x-1/2 z-40 w-full max-w-sm px-4">
                                {currentRoom.status === 'finished' ? (
                                    <div className="bg-indigo-900 text-white p-6 rounded-2xl shadow-2xl text-center border-4 border-yellow-400 animate-bounce-slow">
                                    <Trophy size={48} className="mx-auto text-yellow-400 mb-2"/>
                                    <h2 className="text-3xl font-black">VITTORIA!</h2>
                                    <p className="text-xl opacity-90">{currentRoom.winner}</p>
                                    <button onClick={() => { setView('menu'); setRoomCode(''); }} className="mt-4 bg-white text-indigo-900 px-6 py-2 rounded-full font-bold">Menu</button>
                                    </div>
                                ) : (
                                    <div className="space-y-2 flex flex-col items-center">
                                        
                                        {/* DIRECTION CHOICE UI (GEM HUNT) */}
                                        {directionChoice && (
                                            <div className="w-full bg-white p-4 rounded-2xl shadow-2xl border-4 border-indigo-500 animate-in slide-in-from-bottom flex flex-col items-center gap-4">
                                                <h3 className="font-black text-lg text-indigo-900">SCEGLI DIREZIONE</h3>
                                                <div className="text-4xl font-black text-purple-600 mb-4 animate-bounce">
                                                    HAI FATTO {directionChoice.val}!
                                                </div>
                                                <div className="flex gap-4 w-full">
                                                    <button onClick={() => confirmGemMove(-1)} className="flex-1 bg-red-500 text-white py-3 rounded-xl font-bold flex flex-col items-center hover:scale-105 active:scale-95 transition-all">
                                                        <ArrowLeft size={24}/> INDIETRO
                                                    </button>
                                                    <button onClick={() => confirmGemMove(1)} className="flex-1 bg-green-500 text-white py-3 rounded-xl font-bold flex flex-col items-center hover:scale-105 active:scale-95 transition-all">
                                                        <ArrowRight size={24}/> AVANTI
                                                    </button>
                                                </div>
                                            </div>
                                        )}

                                        {/* DICE BUTTON */}
                                        {!directionChoice && (
                                            <button onClick={handleRoll} 
                                                disabled={
                                                    isRolling || isMoving || 
                                                    (currentPlayer.uid !== user.uid) || 
                                                    currentPlayer.pendingTarget !== null
                                                }
                                                className={`w-full py-4 rounded-2xl font-black text-2xl shadow-xl transition-all flex items-center justify-center gap-3 border-b-8 active:border-b-0 active:translate-y-2 relative overflow-hidden
                                                    ${isRolling || isMoving ? 'bg-slate-300 text-slate-500 border-slate-400' : 
                                                    (currentPlayer.uid === user.uid 
                                                        ? (currentPlayer.pendingTarget !== null 
                                                        ? 'bg-yellow-500 text-white border-yellow-700 hover:bg-yellow-400' 
                                                        : (useSpecialDie 
                                                                ? `${currentPlayerChar.dice.color} text-white border-black/20 hover:opacity-90`
                                                                : 'bg-orange-500 text-white border-orange-700 hover:bg-orange-400')
                                                        )
                                                        : 'bg-slate-100 text-slate-400 border-slate-300 cursor-not-allowed')}`}
                                            >
                                                {isRolling ? <Dice5 className="animate-spin" size={32}/> : (useSpecialDie ? <Dices size={32}/> : <Dice5 size={32}/>)}
                                                <span className="z-10 relative">
                                                    {isRolling ? "..." : (lastRoll ? (currentPlayer.pendingTarget !== null ? "CLICCA LA CASELLA!" : `TIRO: ${lastRoll}`) : "TIRA IL DADO")}
                                                </span>
                                            </button>
                                        )}
                                        
                                        {/* NEXT TURNS QUEUE UI */}
                                        <div className="w-full bg-white/90 backdrop-blur-sm p-2 rounded-xl shadow-lg border border-slate-200 flex flex-col gap-1">
                                            <span className="text-[10px] uppercase font-bold text-slate-400 text-center">Prossimi Turni</span>
                                            <div className="flex justify-center gap-2 overflow-x-auto pb-1">
                                                {Array.from({length: 3}).map((_, i) => {
                                                    let nextIdx = currentRoom.currentTurn;
                                                    for(let k=0; k<=i; k++) nextIdx = getNextTurn(currentRoom.players, nextIdx);
                                                    const nextP = currentRoom.players[nextIdx];
                                                    // SAFETY GUARD
                                                    if (!nextP) return null;
                                                    return (
                                                        <div key={i} className="flex flex-col items-center opacity-70 scale-90">
                                                            <div className="relative">
                                                                <PlayerAvatar charId={nextP.characterId} size="sm" border={false}/>
                                                                <span className="absolute -top-1 -right-1 bg-slate-800 text-white text-[8px] w-4 h-4 rounded-full flex items-center justify-center font-bold">{i+1}</span>
                                                            </div>
                                                        </div>
                                                    )
                                                })}
                                            </div>
                                        </div>

                                        {/* SPECIAL DICE TOGGLE - ENHANCED */}
                                        {currentPlayer.uid === user.uid && currentPlayer.pendingTarget === null && !directionChoice && (
                                            <div className="w-full bg-white p-3 rounded-xl shadow-lg border border-slate-200 animate-in slide-in-from-bottom-2">
                                                <div className="flex justify-between items-center mb-2">
                                                        <div className="flex flex-col leading-tight">
                                                            <span className="text-[10px] font-bold text-slate-400 uppercase">Dado Speciale</span>
                                                            <span className={`font-black ${currentPlayerChar.dice.text}`}>
                                                                {currentPlayerChar.dice.name}
                                                            </span>
                                                        </div>
                                                        <button onClick={() => setUseSpecialDie(!useSpecialDie)} 
                                                            className={`px-3 py-1.5 rounded-lg font-bold text-xs transition-colors ${useSpecialDie ? 'bg-slate-900 text-white' : 'bg-slate-100 text-slate-400'}`}>
                                                            {useSpecialDie ? 'ON' : 'OFF'}
                                                        </button>
                                                </div>
                                                {/* VISUALIZZAZIONE RISULTATI DADO */}
                                                <div className="flex justify-between gap-1">
                                                    {currentPlayerChar.dice.vals.map((v, idx) => (
                                                        <div key={idx} className={`flex-1 aspect-square flex items-center justify-center rounded-md text-xs font-bold border ${v > 0 ? 'bg-green-50 border-green-200 text-green-700' : v < 0 ? 'bg-red-50 border-red-200 text-red-700' : 'bg-slate-50 border-slate-200 text-slate-400'}`}>
                                                            {/* Gem Hunt: Show abs values if possible, otherwise normal */}
                                                            {currentRoom.gameMode === 'gem_hunt' ? Math.abs(v) : v}
                                                        </div>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                            
                            <div className="h-32"></div> 
                        </div>
                        )}
                        
                    </div>

                    {/* SIDEBAR LEADERBOARD (UPDATED FOR TEAMS) */}
                    {view === 'game' && currentRoom && (
                        <div className="hidden lg:flex flex-col w-80 bg-gradient-to-b from-indigo-900 via-purple-900 to-slate-900 text-white shadow-2xl z-20 border-l border-white/10">
                            <div className="p-5 border-b border-white/10 bg-black/20 backdrop-blur-md">
                                <h3 className="font-black text-lg tracking-wider flex items-center gap-2"><Trophy className="text-yellow-400" size={20}/> CLASSIFICA</h3>
                                <p className="text-xs text-white/50 font-medium uppercase tracking-widest">
                                    {currentRoom.gameMode === 'relay' ? 'Team Race' : 'Individuale'}
                                </p>
                            </div>
                            <div className="flex-1 overflow-y-auto p-4 space-y-3">
                                {[...currentRoom.players].sort((a,b) => {
                                    // Complex sort: Finished first, then position, unless dead
                                    if(currentRoom.gameMode === 'relay') {
                                        // Sort by Team first roughly? No, visualize individual runners
                                        if (a.finished && !b.finished) return -1;
                                        if (!a.finished && b.finished) return 1;
                                        return b.position - a.position;
                                    }
                                    if(currentRoom.gameMode === 'gem_hunt') {
                                        if(a.finished && !b.finished) return -1;
                                        if(!a.finished && b.finished) return 1;
                                        // Then by gems
                                        if((a.collectedGems?.length || 0) > (b.collectedGems?.length || 0)) return -1;
                                        if((a.collectedGems?.length || 0) < (b.collectedGems?.length || 0)) return 1;
                                        return 0;
                                    }
                                    if (a.isDead && !b.isDead) return 1;
                                    if (!a.isDead && b.isDead) return -1;
                                    if (a.finished && !b.finished) return -1;
                                    if (!a.finished && b.finished) return 1;
                                    return b.position - a.position; 
                                }).map((p, i) => {
                                    const isMe = p.uid === user.uid;
                                    // SAFETY: check team colors existence
                                    const teamColor = p.teamId !== undefined && TEAM_COLORS[p.teamId] ? TEAM_COLORS[p.teamId] : null;
                                    const locked = currentRoom.gameMode === 'relay' && !p.finished && p.pawnIdx > 0 && 
                                                   !currentRoom.players.find(tm => tm.teamId===p.teamId && tm.pawnIdx===p.pawnIdx-1)?.finished;

                                    return (
                                        <div key={p.id} className={`relative p-3 rounded-xl border backdrop-blur-sm flex items-center gap-3 transition-all
                                            ${isMe ? 'bg-white/10 border-indigo-400' : 'bg-black/20 border-white/5'}
                                            ${teamColor ? teamColor.border.replace('border', 'border-l-4') : ''}
                                            ${locked ? 'opacity-50 grayscale' : ''}
                                            ${i === 0 ? 'ring-2 ring-yellow-400/50 bg-gradient-to-r from-yellow-500/20 to-transparent' : ''}
                                        `}>
                                            <div className="flex flex-col items-center justify-center w-6 mr-1">
                                                {i === 0 ? <Medal size={20} className="text-yellow-400 drop-shadow-lg"/> : 
                                                 i === 1 ? <span className="text-slate-300 font-black text-lg">2°</span> :
                                                 i === 2 ? <span className="text-amber-700 font-black text-lg">3°</span> :
                                                 <span className="text-white/40 font-bold text-sm">{i+1}°</span>}
                                            </div>

                                            <div className="relative">
                                                <PlayerAvatar charId={p.characterId} size="sm" border={isMe}/>
                                                {locked && <div className="absolute inset-0 bg-black/60 rounded-full flex items-center justify-center"><Shield size={12}/></div>}
                                            </div>
                                            <div className="flex-1 min-w-0">
                                                <div className="font-bold text-sm truncate flex items-center gap-2">
                                                    {p.name}
                                                    {teamColor && <span className={`text-[9px] px-1 rounded ${teamColor.bg} text-white`}>T{p.teamId+1}-{p.pawnIdx+1}</span>}
                                                </div>
                                                <div className="text-[10px] text-slate-400 flex gap-2">
                                                    {p.finished ? <span className="text-green-400 font-bold">ARRIVATO!</span> : locked ? 'IN ATTESA' : `CASELLA ${p.position}`}
                                                    {currentRoom.gameMode === 'gem_hunt' && (
                                                        <span className="text-yellow-400 flex items-center gap-0.5"><Gem size={10}/> {p.collectedGems?.length || 0}/3</span>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    )}
                </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>