<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Arcade da Tavolo Online</title>
    
    <!-- React & ReactDOM -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.3/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- FontAwesome & Google Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">

    <!-- Firebase SDKs are imported inside the module script below -->

    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #f0fdf4; /* Light green base */
            background-image: radial-gradient(#dcfce7 2px, transparent 2px);
            background-size: 32px 32px;
            overscroll-behavior: none;
            touch-action: pan-x pan-y;
        }
        .dice-face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 4px;
        }
        .dot {
            background-color: #333;
            border-radius: 50%;
            margin: 2px;
        }
        .btn-press:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 0 rgba(0,0,0,0.1);
        }
        /* Forma customizzata calice */
        .glass-container {
             clip-path: polygon(0% 0%, 100% 0%, 80% 80%, 80% 100%, 20% 100%, 20% 80%);
        }
        /* Forma Bicchieri Colorati (pi√π semplici, tipo cup) */
        .cup-shape {
            clip-path: polygon(0 0, 100% 0, 85% 100%, 15% 100%);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" data-presets="react">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyBSf4LdAEqQVwusujux0TZVay3RhD3aoMY",
            authDomain: "wordle-amiconi.firebaseapp.com",
            projectId: "wordle-amiconi",
            storageBucket: "wordle-amiconi.firebasestorage.app",
            messagingSenderId: "1013530009591",
            appId: "1:1013530009591:web:515ae935ead966705a58f2",
            measurementId: "G-HD8ZPEED82"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = 'boardgames-v1';

        // --- CONSTANTS ---
        const COLORS = [
            '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', 
            '#22c55e', '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', 
            '#3b82f6', '#6366f1', '#8b5cf6', '#a855f7', '#d946ef', 
            '#ec4899', '#f43f5e', '#78716c', '#57534e', '#0f172a'
        ];
        
        const GAME_COLORS = [
            '#FF0000', '#0000FF', '#008000', '#FFFF00', '#800080', '#FFA500', '#00FFFF', '#FFC0CB'
        ];

        const AVATARS = ['üê∂', 'cat', 'üêº', 'ü¶ä', 'ü¶Å', 'üê∏', 'üêô', 'ü¶Ñ', 'ü§ñ', 'üëΩ', 'üëª', 'ü§°'];
        const MODES = [
            { id: 1, name: "First to 1-10", maxPlayers: 6, minPlayers: 1, icon: "fa-list-ol", desc: "Tira i dadi e completa la fila!" },
            { id: 2, name: "Bicchieri d'Uva", maxPlayers: 2, minPlayers: 2, icon: "fa-wine-glass", desc: "Riempi i calici per vincere." },
            { id: 3, name: "Carte Crescenti", maxPlayers: 4, minPlayers: 1, icon: "fa-layer-group", desc: "Trova la sequenza 1-10." },
            { id: 4, name: "Indovina il Colore", maxPlayers: 4, minPlayers: 2, icon: "fa-palette", desc: "Il Leader crea la sequenza, tu indovini!" },
            { id: 5, name: "Punti e Linee", maxPlayers: 4, minPlayers: 2, icon: "fa-border-all", desc: "Chiudi i quadrati nell'arena!" },
            { id: 6, name: "Punti e Linee Random", maxPlayers: 4, minPlayers: 2, icon: "fa-bezier-curve", desc: "Unisci i punti e chiudi le forme!" }
        ];

        // --- UTILS ---
        const generateCode = () => Math.random().toString(36).substring(2, 7).toUpperCase();
        const rollDie = () => Math.floor(Math.random() * 6) + 1;

        // --- COMPONENTS ---
        const Die = ({ value, shaking }) => {
            const dots = {
                1: [[2,2]], 2: [[1,1], [3,3]], 3: [[1,1], [2,2], [3,3]],
                4: [[1,1], [1,3], [3,1], [3,3]], 5: [[1,1], [1,3], [2,2], [3,1], [3,3]],
                6: [[1,1], [1,2], [1,3], [3,1], [3,2], [3,3]]
            };
            return (
                <div className={`w-12 h-12 bg-white rounded-xl border-2 border-gray-300 shadow-sm dice-face ${shaking ? 'animate-spin' : ''}`}>
                    {dots[value]?.map((pos, i) => <div key={i} className="dot" style={{ gridColumn: pos[1], gridRow: pos[0] }}></div>)}
                </div>
            );
        };

        // --- GAME 1: FIRST TO 1-10 ---
        const GameFirstTo10 = ({ G, myPlayerId, updateGame, players }) => {
            const myPlayerIndex = players.findIndex(p => p.id === myPlayerId);
            const isMyTurn = G.turnIndex === myPlayerIndex;
            const currentPlayer = players[G.turnIndex];
            const finished = (G.finishedPlayers || []).find(p => p.id === myPlayerId);

            const handleRoll = () => {
                const d1 = rollDie();
                const d2 = rollDie();
                updateGame({
                    dice: [d1, d2],
                    rolled: true,
                    usedDice: [],
                    message: `${currentPlayer.name} ha tirato ${d1} e ${d2}!`
                });
            };

            const handleNumberClick = (num) => {
                if (!isMyTurn || !G.rolled || finished) return;
                
                const d1 = G.dice[0];
                const d2 = G.dice[1];
                const sum = d1 + d2;
                const myBoard = G.boards[myPlayerId] || [];

                if (myBoard.includes(num)) return;

                let newUsedDice = [...(G.usedDice || [])];
                let isValidMove = false;

                if (num === sum && newUsedDice.length === 0) {
                    newUsedDice = [0, 1];
                    isValidMove = true;
                }
                else if (num === d1 && !newUsedDice.includes(0)) {
                    newUsedDice.push(0);
                    isValidMove = true;
                }
                else if (num === d2 && !newUsedDice.includes(1)) {
                    newUsedDice.push(1);
                    isValidMove = true;
                }

                if (isValidMove) {
                    const newBoard = [...myBoard, num];
                    let msg = G.message;
                    let finishedList = G.finishedPlayers || [];

                    if (newBoard.length === 10) {
                        finishedList = [...finishedList, {id: myPlayerId, time: Date.now()}];
                        msg = `${currentPlayer.name} ha completato il tabellone!`;
                    }

                    updateGame({
                        boards: { ...G.boards, [myPlayerId]: newBoard },
                        usedDice: newUsedDice,
                        finishedPlayers: finishedList,
                        message: msg
                    });
                }
            };

            const passTurn = () => {
                 updateGame({
                    usedDice: [],
                    rolled: false,
                    turnIndex: (G.turnIndex + 1) % players.length,
                    message: `Turno passato a ${players[(G.turnIndex + 1) % players.length].name}.`
                 });
            };

            return (
                <div className="flex flex-col items-center w-full max-w-4xl mx-auto p-2">
                    <div className="bg-white rounded-2xl p-4 shadow-lg w-full mb-6 flex flex-col items-center sticky top-16 z-10 border border-gray-100">
                        <h2 className="text-xl font-bold mb-2 text-gray-700">Turno di: <span style={{color: currentPlayer?.color}}>{currentPlayer?.name}</span></h2>
                        
                        <div className="flex gap-4 mb-4">
                            {G.dice.map((d, i) => (
                                <div key={i} className={`transform transition-all ${G.usedDice?.includes(i) ? 'opacity-30 scale-90 grayscale' : 'opacity-100'}`}>
                                    <Die value={d || 1} shaking={!G.rolled && isMyTurn} />
                                </div>
                            ))}
                        </div>

                        {isMyTurn && !finished ? (
                            <div className="flex gap-2">
                                {!G.rolled ? (
                                    <button onClick={handleRoll} className="bg-blue-500 text-white px-8 py-3 rounded-full font-bold shadow-md btn-press text-lg">
                                        LANCIA DADI
                                    </button>
                                ) : (
                                    <div className="flex flex-col items-center gap-2">
                                        <button onClick={passTurn} className="bg-gray-800 text-white px-8 py-2 rounded-full font-bold shadow-md btn-press">
                                            PASSA TURNO <i className="fa-solid fa-forward ml-2"></i>
                                        </button>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className="text-sm text-gray-500 italic">
                                {finished ? "Hai completato il tabellone!" : "In attesa..."}
                            </div>
                        )}
                        <p className="mt-2 text-sm text-gray-500">{G.message}</p>
                    </div>

                    <div className="w-full grid gap-4">
                        {players.map((p, idx) => {
                            const isMe = p.id === myPlayerId;
                            const pBoard = G.boards[p.id] || [];
                            const isFinished = (G.finishedPlayers || []).find(fp => fp.id === p.id);
                            
                            return (
                                <div key={p.id} className={`bg-white rounded-xl p-3 shadow-md border-l-8 ${G.turnIndex === idx ? 'ring-2 ring-yellow-400' : ''}`} style={{ borderLeftColor: p.color }}>
                                    <div className="flex justify-between items-center mb-2">
                                        <div className="flex items-center gap-2">
                                            <span className="text-2xl">{p.avatar || 'üë§'}</span>
                                            <span className="font-bold text-gray-800">{p.name}</span>
                                            {isFinished && <span className="text-xs bg-yellow-300 px-2 py-1 rounded-full text-yellow-800">üèÜ FINITO</span>}
                                        </div>
                                    </div>
                                    <div className="flex justify-between gap-1 overflow-x-auto pb-2">
                                        {[1,2,3,4,5,6,7,8,9,10].map(num => {
                                            const marked = pBoard.includes(num);
                                            return (
                                                <button 
                                                    key={num}
                                                    onClick={() => isMe ? handleNumberClick(num) : null}
                                                    disabled={!isMe || marked}
                                                    className={`
                                                        w-8 h-10 sm:w-10 sm:h-14 rounded-md flex items-center justify-center text-lg font-bold transition-all
                                                        ${marked 
                                                            ? `bg-gray-800 text-white opacity-50 cursor-not-allowed` 
                                                            : isMe && isMyTurn && G.rolled && !finished
                                                                ? 'bg-white border-2 border-gray-200 text-gray-700 hover:border-gray-400 cursor-pointer shadow-sm active:scale-95' 
                                                                : 'bg-gray-100 text-gray-300 cursor-default'}
                                                    `}
                                                    style={marked ? {backgroundColor: p.color, color: 'white'} : {}}
                                                >
                                                    {marked ? 'X' : num}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- GAME 2: GRAPE GOBLETS ---
        const GameGrapes = ({ G, myPlayerId, updateGame, players }) => {
            const [localRolling, setLocalRolling] = React.useState(false);
            const [localDieVal, setLocalDieVal] = React.useState(1);
            if (players.length < 2) return <div className="p-4 text-center">In attesa del secondo giocatore...</div>;
            const myPlayerIndex = players.findIndex(p => p.id === myPlayerId);
            const isMyTurn = G.turnIndex === myPlayerIndex;
            const currentPlayer = players[G.turnIndex];
            if (!G.glasses) return <div>Inizializzazione...</div>;

            const animateAndRoll = () => {
                if (localRolling) return;
                setLocalRolling(true);
                setTimeout(() => {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    setLocalDieVal(roll);
                    setLocalRolling(false);
                    updateGame({ currentRoll: roll, remainingMoves: roll, rolled: true, message: `${currentPlayer.name} ha tirato un ${roll}. Distribuisci!` });
                }, 1000);
            };

            const fillGlass = (glassIdx) => {
                if (!isMyTurn || !G.rolled || G.remainingMoves <= 0 || localRolling) return;
                const glass = G.glasses[glassIdx];
                const isCenter = glassIdx === 1;
                const myGlassIdx = players[0].id === currentPlayer.id ? 0 : 2;
                const myGlassFull = !G.glasses[myGlassIdx].dots.includes(null);
                
                if (!myGlassFull && glassIdx !== myGlassIdx) { alert("Devi riempire prima il tuo calice!"); return; }
                if (glass.ownerId && glass.ownerId !== currentPlayer.id) return;
                if (!glass.dots.includes(null)) return;

                const newGlasses = [...G.glasses];
                const newDots = [...glass.dots];
                let fillIndex = -1;
                if (!isCenter) fillIndex = newDots.indexOf(null);
                else {
                    if (players[0].id === currentPlayer.id) fillIndex = newDots.indexOf(null); 
                    else fillIndex = newDots.lastIndexOf(null); 
                }
                if (fillIndex === -1) return;
                newDots[fillIndex] = currentPlayer.id; 
                newGlasses[glassIdx] = { ...glass, dots: newDots };

                const newRemaining = G.remainingMoves - 1;
                let nextTurn = G.turnIndex;
                let resetRolled = G.rolled;
                let resetMsg = G.message;

                if (newRemaining === 0) {
                    nextTurn = (G.turnIndex + 1) % 2;
                    resetRolled = false;
                    resetMsg = `Turno di ${players[nextTurn].name}`;
                    setLocalDieVal(1);
                }
                const allFull = newGlasses.every(g => !g.dots.includes(null));
                let winnerId = null;
                if (allFull) {
                    let p1Count = 0; let p2Count = 0;
                    const p1Id = players[0].id; const p2Id = players[1].id;
                    newGlasses.forEach(g => { g.dots.forEach(d => { if (d === p1Id) p1Count++; if (d === p2Id) p2Count++; }); });
                    winnerId = p1Count > p2Count ? p1Id : (p2Count > p1Count ? p2Id : 'draw');
                    resetMsg = winnerId === 'draw' ? "Pareggio!" : `Vince ${players.find(p=>p.id===winnerId)?.name}!`;
                }
                updateGame({ glasses: newGlasses, remainingMoves: newRemaining, turnIndex: nextTurn, rolled: resetRolled, message: resetMsg, winner: winnerId });
            };

            const renderGlass = (glass, idx) => {
                const rows = [ glass.dots.slice(0, 5), glass.dots.slice(5, 9), glass.dots.slice(9, 11), glass.dots.slice(11, 13) ];
                return (
                    <div onClick={() => fillGlass(idx)} className={`flex flex-col items-center cursor-pointer transition-transform hover:scale-105 ${isMyTurn && G.rolled && G.remainingMoves > 0 ? 'ring-4 ring-green-400 rounded-lg p-1' : ''}`}>
                        <div className="glass-container w-32 h-44 bg-blue-50 border-4 border-blue-200 relative flex flex-col items-center pt-2 gap-1 shadow-xl">
                            {rows.map((row, rIdx) => (
                                <div key={rIdx} className="flex gap-1 justify-center">
                                    {row.map((owner, dIdx) => {
                                        const isFilled = owner !== null;
                                        let bg = 'bg-gray-100';
                                        if (isFilled) {
                                            const p = players.find(pl => pl.id === owner);
                                            bg = p ? p.color : '#333';
                                        }
                                        return <div key={dIdx} className="w-5 h-5 rounded-full border border-gray-300" style={{ backgroundColor: isFilled ? bg : '#f3f4f6' }}></div>;
                                    })}
                                </div>
                            ))}
                        </div>
                        <div className="h-12 w-3 bg-blue-200"></div>
                        <div className="h-3 w-16 bg-blue-200 rounded-full"></div>
                        <span className="mt-1 font-bold bg-white px-2 rounded text-xs border">{glass.ownerId ? players.find(p=>p.id===glass.ownerId)?.name : 'Centro'}</span>
                    </div>
                );
            };

            return (
                <div className="flex flex-col items-center w-full">
                    {G.winner ? (
                        <div className="text-3xl font-bold text-green-600 animate-bounce mb-10 text-center">üéâ {players.find(p=>p.id===G.winner)?.name || "Pareggio"} Ha Vinto! üéâ</div>
                    ) : (
                        <div className="flex flex-col items-center w-full mb-4">
                            <h2 className="text-xl font-bold bg-white px-4 py-2 rounded-full shadow mb-4">Turno di {currentPlayer.name}</h2>
                            <div className="flex flex-col items-center gap-3 bg-white p-4 rounded-xl shadow-lg">
                                <Die value={G.rolled ? G.currentRoll : localDieVal} shaking={localRolling} />
                                {isMyTurn && !G.rolled && !localRolling && <button onClick={animateAndRoll} className="bg-purple-600 text-white px-6 py-2 rounded-full font-bold shadow-md btn-press">LANCIA IL DADO</button>}
                                {localRolling && <div className="text-purple-500 font-bold">Rotolando...</div>}
                                {G.rolled && <div className="text-2xl font-bold text-purple-600 animate-pulse">Da mettere: {G.remainingMoves}</div>}
                            </div>
                            <p className="mt-2 text-gray-500 font-bold">{G.message}</p>
                        </div>
                    )}
                    <div className="flex flex-wrap justify-center items-end gap-2 sm:gap-6 mt-2">
                        {renderGlass(G.glasses[0], 0)} {renderGlass(G.glasses[1], 1)} {renderGlass(G.glasses[2], 2)}
                    </div>
                </div>
            )
        };

        // --- GAME 3: ASCENDING CARDS ---
        const GameCards = ({ G, myPlayerId, updateGame, players }) => {
            const myPlayerIndex = players.findIndex(p => p.id === myPlayerId);
            const isMyTurn = G.turnIndex === myPlayerIndex;
            const currentPlayer = players[G.turnIndex];

            const handleCardClick = (pId, cIdx) => {
                if (!isMyTurn || pId !== myPlayerId || G.waitingReset) return;
                const pData = G.playerData[myPlayerId];
                if (pData.visible[cIdx]) return;
                const cardValue = pData.cards[cIdx];
                const target = pData.target;
                let newVisible = [...pData.visible];
                let newTarget = target;
                let waitReset = false;
                let msg = "";
                newVisible[cIdx] = true;

                if (cardValue === target) {
                    newTarget++;
                    msg = `Bravo! Ora cerca il ${newTarget}.`;
                    if (newTarget > 10) {
                         const newFinished = [...(G.finishedPlayers || []), {id: myPlayerId, time: Date.now()}];
                         msg = `${currentPlayer.name} ha vinto!`;
                         updateGame({ playerData: { ...G.playerData, [myPlayerId]: { ...pData, visible: newVisible, target: newTarget } }, finishedPlayers: newFinished, message: msg });
                        return;
                    }
                } else {
                    msg = `No! Era un ${cardValue}. RESET!`;
                    waitReset = true;
                }
                updateGame({ playerData: { ...G.playerData, [myPlayerId]: { ...pData, visible: newVisible, target: newTarget } }, waitingReset: waitReset, message: msg });
                if (waitReset) {
                    setTimeout(() => {
                        const resetVisible = Array(10).fill(false);
                        const resetTarget = 1;
                        updateGame({ playerData: { ...G.playerData, [myPlayerId]: { ...pData, visible: resetVisible, target: resetTarget } }, turnIndex: (G.turnIndex + 1) % players.length, waitingReset: false, message: `Tocca a ${players[(G.turnIndex + 1) % players.length].name}` });
                    }, 2000);
                }
            };
            return (
                <div className="w-full max-w-5xl mx-auto flex flex-col gap-6">
                     <div className="bg-white p-3 rounded-xl shadow text-center sticky top-0 z-20">
                        <h2 className="text-xl font-bold text-indigo-700">Turno: {currentPlayer.name}</h2>
                        <p className="text-gray-500 font-bold">{G.message}</p>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {players.map((p, pIdx) => {
                            const pData = G.playerData[p.id];
                            return (
                                <div key={p.id} className={`p-4 rounded-xl border-4 relative ${G.turnIndex === pIdx ? 'bg-indigo-50 border-indigo-300' : 'bg-white border-gray-100'}`}>
                                    <div className="flex justify-between items-center mb-3">
                                        <div className="flex items-center gap-2"><span className="text-2xl">{p.avatar}</span><span className="font-bold" style={{color: p.color}}>{p.name}</span></div>
                                        <div className="text-sm font-bold text-gray-400">Target: {pData?.target}</div>
                                    </div>
                                    <div className="grid grid-cols-5 gap-2">
                                        {pData?.cards.map((val, cIdx) => {
                                            const isVisible = pData.visible[cIdx];
                                            return <div key={cIdx} onClick={() => handleCardClick(p.id, cIdx)} className={`aspect-[3/4] rounded-lg shadow-sm flex items-center justify-center text-xl font-bold cursor-pointer transition-all duration-500 transform ${isVisible ? 'bg-white rotate-0' : 'bg-indigo-500 rotate-y-180'}`} style={{backgroundColor: isVisible ? 'white' : p.color}}>{isVisible ? val : <i className="fa-solid fa-gamepad text-white opacity-20"></i>}</div>;
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // --- GAME 4: GUESS THE COLOR ---
        const GameGuessColor = ({ G, myPlayerId, updateGame, players }) => {
            const currentRound = G.rounds[G.currentRoundIndex];
            if (G.phase === 'game_end') {
                const sortedResults = [...G.results].sort((a, b) => a.timeMs - b.timeMs);
                return (
                    <div className="flex flex-col items-center w-full max-w-2xl mx-auto p-4 bg-white rounded-xl shadow-lg mt-8">
                        <h2 className="text-3xl font-bold text-indigo-700 mb-6">üèÜ Classifica Finale üèÜ</h2>
                        <div className="w-full space-y-4">{sortedResults.map((res, i) => { const p = players.find(x => x.id === res.guesserId); return (<div key={i} className={`flex items-center justify-between p-4 rounded-lg border-2 ${i===0 ? 'bg-yellow-50 border-yellow-400' : 'bg-gray-50 border-gray-200'}`}><div className="flex items-center gap-3"><div className="font-bold text-2xl text-gray-400 w-8">{i+1}¬∞</div><div className="text-2xl">{p?.avatar}</div><div className="font-bold text-lg">{p?.name}</div></div><div className="font-mono text-xl font-bold text-indigo-600">{(res.timeMs / 1000).toFixed(2)}s</div></div>)})}</div>
                        <div className="mt-8 text-center text-gray-500">Grazie per aver giocato!</div>
                    </div>
                );
            }
            const isLeader = myPlayerId === currentRound.leaderId;
            const isGuesser = myPlayerId === currentRound.guesserId;
            const leaderName = players.find(p => p.id === currentRound.leaderId)?.name;
            const guesserName = players.find(p => p.id === currentRound.guesserId)?.name;
            const [timerMs, setTimerMs] = React.useState(0);
            React.useEffect(() => { let interval; if (G.phase === 'guessing') { interval = setInterval(() => { setTimerMs(Date.now() - G.roundStartTime); }, 100); } else { setTimerMs(0); } return () => clearInterval(interval); }, [G.phase, G.roundStartTime]);
            const [selectedIndex, setSelectedIndex] = React.useState(null);
            let displayColors = []; let canInteract = false; let statusText = ""; let subText = "";
            if (G.phase === 'setup') {
                if (isLeader) { displayColors = G.secretCode; canInteract = true; statusText = "TOCCA A TE: Crea la sequenza!"; subText = `L'indovino sar√† ${guesserName}`; } 
                else { displayColors = Array(8).fill('#ddd'); canInteract = false; statusText = `Turno di ${leaderName}`; subText = "Sta creando la sequenza segreta..."; }
            } else if (G.phase === 'guessing') {
                displayColors = G.currentGuess; canInteract = isGuesser;
                if (isGuesser) { statusText = "INDOVINA ORA!"; subText = "Ordina i bicchieri il pi√π velocemente possibile!"; } 
                else { statusText = `Turno di ${guesserName}`; subText = "Sta cercando di indovinare..."; }
            } else if (G.phase === 'round_end') {
                displayColors = G.secretCode; canInteract = false; statusText = "Round Completato!"; subText = `${guesserName} ha impiegato ${((G.lastRoundTime || 0)/1000).toFixed(2)}s`;
            }

            const handleSlotClick = (idx) => {
                if (!canInteract) return;
                if (selectedIndex === null) setSelectedIndex(idx);
                else {
                    const newList = [...displayColors]; const temp = newList[selectedIndex]; newList[selectedIndex] = newList[idx]; newList[idx] = temp;
                    if (G.phase === 'setup') updateGame({ secretCode: newList }); else updateGame({ currentGuess: newList });
                    setSelectedIndex(null);
                }
            };
            const confirmCode = () => { const shuffled = [...G.secretCode].sort(() => Math.random() - 0.5); updateGame({ phase: 'guessing', currentGuess: shuffled, roundStartTime: Date.now(), message: "Tempo partito!" }); setSelectedIndex(null); };
            const checkGuess = () => {
                let correctCount = 0; G.currentGuess.forEach((color, i) => { if (color === G.secretCode[i]) correctCount++; });
                if (correctCount === 8) {
                    const timeTaken = Date.now() - G.roundStartTime;
                    const newResults = [...(G.results || []), { guesserId: currentRound.guesserId, timeMs: timeTaken }];
                    updateGame({ phase: 'round_end', results: newResults, lastRoundTime: timeTaken, feedback: "CORRETTO!", message: "Round finito." });
                } else updateGame({ feedback: `${correctCount} bicchieri corretti.`, message: "Riprova!" });
            };
            const nextRound = () => {
                const nextIdx = G.currentRoundIndex + 1;
                if (nextIdx >= G.rounds.length) updateGame({ phase: 'game_end' });
                else updateGame({ phase: 'setup', currentRoundIndex: nextIdx, secretCode: [...GAME_COLORS], currentGuess: [], feedback: "" });
            };
            return (
                <div className="flex flex-col items-center w-full max-w-4xl mx-auto p-4">
                    <div className="bg-white rounded-xl shadow-lg p-6 w-full text-center mb-8 sticky top-0 z-20 border-b-4 border-indigo-200">
                        <div className="flex justify-between items-center mb-2 px-2 text-sm font-bold text-gray-400 uppercase tracking-widest"><div>Round {G.currentRoundIndex + 1} / {G.rounds.length}</div>{G.phase === 'guessing' && <div className="text-red-500 text-xl font-mono">{(timerMs/1000).toFixed(1)}s</div>}</div>
                        <h2 className="text-2xl font-bold text-gray-800">{statusText}</h2>
                        <p className="text-gray-500 mb-2">{subText}</p>
                        {G.feedback && <div className="text-indigo-600 font-bold text-lg mb-2 animate-pulse">{G.feedback}</div>}
                        <div className="mt-4 h-12 flex justify-center">
                            {G.phase === 'setup' && isLeader && <button onClick={confirmCode} className="bg-black text-white px-8 py-2 rounded-full font-bold shadow-lg btn-press hover:bg-gray-800">CONFERMA CODICE E AVVIA</button>}
                            {G.phase === 'guessing' && isGuesser && <button onClick={checkGuess} className="bg-green-500 text-white px-8 py-2 rounded-full font-bold shadow-lg btn-press hover:bg-green-600">VERIFICA SEQUENZA</button>}
                            {G.phase === 'round_end' && <button onClick={nextRound} className="bg-blue-500 text-white px-8 py-2 rounded-full font-bold shadow-lg btn-press hover:bg-blue-600">{G.currentRoundIndex + 1 >= G.rounds.length ? "VAI ALLA CLASSIFICA" : "PROSSIMO ROUND"}</button>}
                        </div>
                    </div>
                    <div className="flex justify-center gap-2 sm:gap-4 flex-wrap bg-indigo-50 p-4 sm:p-8 rounded-2xl shadow-inner w-full">
                        {displayColors.map((color, idx) => (
                            <div key={idx} onClick={() => handleSlotClick(idx)} className={`relative w-12 h-16 sm:w-16 sm:h-24 flex items-end justify-center transition-all duration-200 ${canInteract ? 'cursor-pointer hover:-translate-y-2' : 'cursor-default'} ${selectedIndex === idx ? 'ring-4 ring-offset-2 ring-black scale-110 z-10' : ''}`}>
                                <div className="absolute bottom-0 w-10 h-2 bg-black/20 rounded-full blur-sm"></div>
                                <div className="cup-shape w-full h-full shadow-inner" style={{ backgroundColor: color, boxShadow: 'inset -5px 0 10px rgba(0,0,0,0.1)' }}><div className="absolute top-2 left-2 w-2 h-full bg-white/30 skew-x-12 rounded-full"></div></div>
                                <div className="absolute -bottom-8 font-bold text-gray-400 text-sm">{idx + 1}</div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- GAME 5: DOTS & BOXES (Grid) ---
        const GameDotsAndBoxes = ({ G, myPlayerId, updateGame, players }) => {
            const myPlayerIndex = players.findIndex(p => p.id === myPlayerId);
            const isMyTurn = G.turnIndex === myPlayerIndex;
            const currentPlayer = players[G.turnIndex];
            
            const [localRolling, setLocalRolling] = React.useState(false);
            const [localDieVal, setLocalDieVal] = React.useState(1);

            const animateAndRoll = () => {
                if (localRolling) return;
                setLocalRolling(true);
                setTimeout(() => {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    const moves = roll; // User requested EXACT roll = moves
                    
                    setLocalDieVal(roll);
                    setLocalRolling(false);
                    updateGame({
                        currentRoll: roll,
                        movesLeft: moves,
                        rolled: true,
                        message: `${currentPlayer.name} ha ${moves} mosse!`
                    });
                }, 800);
            };

            const gridWidth = G.gridSize.cols;
            const gridHeight = G.gridSize.rows;

            // Helper to get line ID
            const getLineId = (type, r, c) => `${type}-${r}-${c}`;

            const handleLineClick = (type, r, c) => {
                if (!isMyTurn || !G.rolled || G.movesLeft <= 0 || localRolling) return;
                
                const lineId = getLineId(type, r, c);
                // Check if already taken
                if (G.lines[lineId]) return;

                const newLines = { ...G.lines, [lineId]: currentPlayer.id };
                let pointsGained = 0;
                const newBoxes = { ...G.boxes };

                // Check Boxes
                const checkBox = (br, bc) => {
                    if (br < 0 || bc < 0 || br >= gridHeight || bc >= gridWidth) return false;
                    const top = newLines[getLineId('h', br, bc)];
                    const bottom = newLines[getLineId('h', br+1, bc)];
                    const left = newLines[getLineId('v', br, bc)];
                    const right = newLines[getLineId('v', br, bc+1)];
                    
                    if (top && bottom && left && right && !newBoxes[`${br}-${bc}`]) {
                        newBoxes[`${br}-${bc}`] = currentPlayer.id;
                        return true;
                    }
                    return false;
                };

                if (type === 'h') {
                    if (checkBox(r, c)) pointsGained++;     // Box below line
                    if (checkBox(r-1, c)) pointsGained++;   // Box above line
                } else {
                    if (checkBox(r, c)) pointsGained++;     // Box to right
                    if (checkBox(r, c-1)) pointsGained++;   // Box to left
                }

                // Update scores
                const newScores = { ...G.scores };
                if (pointsGained > 0) {
                    newScores[currentPlayer.id] = (newScores[currentPlayer.id] || 0) + pointsGained;
                }

                // Move logic
                const newMoves = G.movesLeft - 1;
                let nextTurn = G.turnIndex;
                let resetRolled = G.rolled;
                let resetMsg = G.message;

                const totalBoxes = gridWidth * gridHeight;
                const filledBoxes = Object.keys(newBoxes).length;

                if (filledBoxes === totalBoxes) {
                    let winnerId = null;
                    let maxScore = -1;
                    players.forEach(p => {
                        const s = newScores[p.id] || 0;
                        if (s > maxScore) { maxScore = s; winnerId = p.id; }
                        else if (s === maxScore) winnerId = 'draw';
                    });
                    
                    updateGame({
                        lines: newLines,
                        boxes: newBoxes,
                        scores: newScores,
                        movesLeft: 0,
                        winner: winnerId,
                        message: "Tutti i box sono chiusi!"
                    });
                    return;
                }

                if (newMoves <= 0) {
                    nextTurn = (G.turnIndex + 1) % players.length;
                    resetRolled = false;
                    resetMsg = `Turno di ${players[nextTurn].name}`;
                    setLocalDieVal(1);
                } else {
                    resetMsg = `${currentPlayer.name}: ancora ${newMoves} mosse!`;
                }

                updateGame({
                    lines: newLines,
                    boxes: newBoxes,
                    scores: newScores,
                    movesLeft: newMoves,
                    turnIndex: nextTurn,
                    rolled: resetRolled,
                    message: resetMsg
                });
            };
            
            const renderGrid = () => {
                const elements = [];
                for (let r = 0; r <= gridHeight; r++) {
                    const dotRow = [];
                    for (let c = 0; c <= gridWidth; c++) {
                        dotRow.push(
                            <div key={`dot-${r}-${c}`} className="w-2 h-2 sm:w-3 sm:h-3 bg-black rounded-full z-10 relative"></div>
                        );
                        if (c < gridWidth) {
                            const lineId = getLineId('h', r, c);
                            const ownerId = G.lines[lineId];
                            const owner = players.find(p => p.id === ownerId);
                            const color = owner ? owner.color : '#e5e7eb';
                            
                            dotRow.push(
                                <div 
                                    key={`h-${r}-${c}`}
                                    onClick={() => handleLineClick('h', r, c)}
                                    className={`h-2 sm:h-3 flex-1 mx-[-1px] cursor-pointer transition-colors duration-200 ${ownerId ? '' : 'hover:bg-gray-400'}`}
                                    style={{ backgroundColor: color }}
                                ></div>
                            );
                        }
                    }
                    elements.push(<div key={`row-dots-${r}`} className="flex items-center justify-between">{dotRow}</div>);

                    if (r < gridHeight) {
                        const boxRow = [];
                        for (let c = 0; c <= gridWidth; c++) {
                            const lineId = getLineId('v', r, c);
                            const ownerId = G.lines[lineId];
                            const owner = players.find(p => p.id === ownerId);
                            const color = owner ? owner.color : '#e5e7eb';

                            boxRow.push(
                                <div 
                                    key={`v-${r}-${c}`}
                                    onClick={() => handleLineClick('v', r, c)}
                                    className={`w-2 sm:w-3 h-8 sm:h-12 my-[-1px] cursor-pointer transition-colors duration-200 ${ownerId ? '' : 'hover:bg-gray-400'}`}
                                    style={{ backgroundColor: color }}
                                ></div>
                            );

                            if (c < gridWidth) {
                                const boxOwnerId = G.boxes[`${r}-${c}`];
                                const boxOwner = players.find(p => p.id === boxOwnerId);
                                
                                boxRow.push(
                                    <div key={`box-${r}-${c}`} className="flex-1 h-8 sm:h-12 flex items-center justify-center transition-all duration-500"
                                         style={boxOwnerId ? {
                                             background: `linear-gradient(135deg, ${boxOwner.color} 0%, rgba(255,255,255,0.8) 100%)`
                                         } : {}}
                                    >
                                        {boxOwnerId && <span className="text-sm sm:text-xl drop-shadow-md">{boxOwner.avatar}</span>}
                                    </div>
                                );
                            }
                        }
                        elements.push(<div key={`row-boxes-${r}`} className="flex">{boxRow}</div>);
                    }
                }
                return elements;
            };

            return (
                <div className="flex flex-col items-center w-full max-w-3xl mx-auto p-2">
                    {/* Header */}
                    {G.winner ? (
                         <div className="text-3xl font-bold text-green-600 animate-bounce mb-10 text-center">
                            üéâ {players.find(p=>p.id===G.winner)?.name || "Pareggio"} Ha Vinto! üéâ
                        </div>
                    ) : (
                        <div className="flex flex-col items-center w-full mb-4 sticky top-16 z-20">
                            <h2 className="text-xl font-bold bg-white px-4 py-2 rounded-full shadow mb-2">Turno di {currentPlayer.name}</h2>
                            <div className="flex items-center gap-4 bg-white p-2 rounded-xl shadow-lg border">
                                <Die value={G.rolled ? G.currentRoll : localDieVal} shaking={localRolling} />
                                {isMyTurn && !G.rolled && !localRolling && (
                                    <button onClick={animateAndRoll} className="bg-purple-600 text-white px-4 py-2 rounded-full font-bold shadow-md btn-press">LANCIA</button>
                                )}
                                <div className="font-bold text-gray-500 w-32 text-center">
                                    {G.rolled ? `Mosse: ${G.movesLeft}` : "Tira il dado!"}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Scores */}
                    <div className="flex flex-wrap justify-center gap-4 mb-4 w-full">
                        {players.map(p => (
                            <div key={p.id} className={`flex items-center gap-2 px-3 py-1 rounded-full border-2 ${G.scores[p.id] > 0 ? 'bg-white' : 'bg-gray-100'}`} style={{borderColor: p.color}}>
                                <span>{p.avatar}</span>
                                <span className="font-bold">{G.scores[p.id] || 0}</span>
                            </div>
                        ))}
                    </div>

                    {/* Arena */}
                    <div className="bg-white p-4 sm:p-6 rounded-xl shadow-2xl border-4 border-gray-100 w-full select-none" style={{touchAction: 'none'}}>
                        {renderGrid()}
                    </div>
                </div>
            );
        };

        // --- GAME 6: RANDOMIZED DOTS & BOXES (True Random + Cycle Detection) ---
        const GameRandomDots = ({ G, myPlayerId, updateGame, players }) => {
            const myPlayerIndex = players.findIndex(p => p.id === myPlayerId);
            const isMyTurn = G.turnIndex === myPlayerIndex;
            const currentPlayer = players[G.turnIndex];
            
            const [localRolling, setLocalRolling] = React.useState(false);
            const [localDieVal, setLocalDieVal] = React.useState(1);
            
            // Drag state
            const [dragStart, setDragStart] = React.useState(null); 
            const [dragCurrent, setDragCurrent] = React.useState(null); 
            const svgRef = React.useRef(null);

            // --- GENERAZIONE NODI (POISSON-DISC LIKE) ---
            React.useEffect(() => {
                if (!G.nodes || G.nodes.length === 0) {
                    const width = 350; // Viewbox width
                    const height = 450;
                    const radius = 35; // Min dist
                    const newNodes = [];
                    let attempts = 0;
                    const maxNodes = 35;

                    while(newNodes.length < maxNodes && attempts < 2000) {
                        const x = 30 + Math.random() * (width - 60);
                        const y = 30 + Math.random() * (height - 60);
                        let valid = true;
                        for(let n of newNodes) {
                            if (Math.hypot(n.x - x, n.y - y) < radius) {
                                valid = false;
                                break;
                            }
                        }
                        if (valid) newNodes.push({ id: newNodes.length, x, y });
                        attempts++;
                    }
                    updateGame({ nodes: newNodes });
                }
            }, []);

            if (!G.nodes) return <div>Generazione caos...</div>;

            const animateAndRoll = () => {
                if (localRolling) return;
                setLocalRolling(true);
                setTimeout(() => {
                    const roll = Math.floor(Math.random() * 6) + 1;
                    setLocalDieVal(roll);
                    setLocalRolling(false);
                    updateGame({
                        currentRoll: roll,
                        movesLeft: roll,
                        rolled: true,
                        message: `${currentPlayer.name} ha ${roll} mosse!`
                    });
                }, 800);
            };

            // --- UTILS PER GEOMETRIA ---
            const getCoordinates = (e) => {
                if (!svgRef.current) return { x: 0, y: 0 };
                const svg = svgRef.current;
                const CTM = svg.getScreenCTM();
                let clientX, clientY;
                if (e.touches) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; }
                else if (e.changedTouches) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
                else { clientX = e.clientX; clientY = e.clientY; }
                if (CTM) return { x: (clientX - CTM.e) / CTM.a, y: (clientY - CTM.f) / CTM.d };
                return { x: 0, y: 0 };
            };

            // Controlla se due segmenti (p1-q1) e (p2-q2) si intersecano
            const orientation = (p, q, r) => {
                const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                if (val === 0) return 0;
                return (val > 0) ? 1 : 2;
            };
            const doIntersect = (p1, q1, p2, q2) => {
                const o1 = orientation(p1, q1, p2);
                const o2 = orientation(p1, q1, q2);
                const o3 = orientation(p2, q2, p1);
                const o4 = orientation(p2, q2, q1);
                if (o1 !== o2 && o3 !== o4) return true;
                return false;
            };

            // --- ALGORITMO CICLI (BFS SHORTEST PATH) ---
            const findShortestCycle = (startId, endId, currentEdges) => {
                // Costruisci grafo adiacenze
                const adj = {};
                currentEdges.forEach(e => {
                    if(!adj[e.u]) adj[e.u] = [];
                    if(!adj[e.v]) adj[e.v] = [];
                    adj[e.u].push(e.v);
                    adj[e.v].push(e.u);
                });

                // BFS per trovare percorso da endId a startId
                const queue = [[endId, [endId]]];
                const visited = new Set();
                visited.add(endId);

                while(queue.length > 0) {
                    const [node, path] = queue.shift();
                    if (node === startId) return path; // Ciclo trovato!

                    const neighbors = adj[node] || [];
                    for(let neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([neighbor, [...path, neighbor]]);
                        }
                    }
                }
                return null;
            };

            const attemptConnection = (n1, n2) => {
                if (!isMyTurn || !G.rolled || G.movesLeft <= 0) return;

                // 1. Esiste gi√†?
                const u = Math.min(n1.id, n2.id);
                const v = Math.max(n1.id, n2.id);
                if (G.edges.some(e => e.u === u && e.v === v)) return;

                // 2. Interseca altre linee?
                for (let e of G.edges) {
                    const nA = G.nodes[e.u];
                    const nB = G.nodes[e.v];
                    // Escludi linee che condividono un vertice (non sono intersezioni)
                    if (nA.id === n1.id || nA.id === n2.id || nB.id === n1.id || nB.id === n2.id) continue;
                    if (doIntersect(n1, n2, nA, nB)) {
                         alert("Non puoi incrociare le linee!");
                         return;
                    }
                }

                // 3. Controllo Cicli (Prima di aggiungere edge)
                const cyclePath = findShortestCycle(u, v, G.edges);
                
                // Commit
                const newEdges = [...G.edges, { u, v, ownerId: currentPlayer.id }];
                const newPolygons = [...G.polygons];
                const newScores = { ...G.scores };
                let pointsGained = 0;

                if (cyclePath) {
                    // Crea poligono
                    pointsGained = 1;
                    newScores[currentPlayer.id] = (newScores[currentPlayer.id] || 0) + 1;
                    newPolygons.push({
                        points: cyclePath, // array of IDs
                        ownerId: currentPlayer.id
                    });
                }

                // Fine Turno?
                const newMoves = G.movesLeft - 1;
                let nextTurn = G.turnIndex;
                let resetRolled = G.rolled;
                let resetMsg = G.message;

                // Condizione vittoria semplice (es. punteggio 10 o tempo, qui infinito finch√© non si stufano)
                // Ma per ora lasciamo scorrere

                if (newMoves <= 0) {
                    nextTurn = (G.turnIndex + 1) % players.length;
                    resetRolled = false;
                    resetMsg = `Turno di ${players[nextTurn].name}`;
                    setLocalDieVal(1);
                } else {
                    resetMsg = `${currentPlayer.name}: ancora ${newMoves} mosse!`;
                }

                updateGame({
                    edges: newEdges,
                    polygons: newPolygons,
                    scores: newScores,
                    movesLeft: newMoves,
                    turnIndex: nextTurn,
                    rolled: resetRolled,
                    message: pointsGained > 0 ? "Ciclo Chiuso! +1 Punto!" : resetMsg
                });
            };

            const handleStart = (n, e) => {
                if (!isMyTurn || !G.rolled || G.movesLeft <= 0) return;
                e.stopPropagation();
                setDragStart(n);
                setDragCurrent({ x: n.x, y: n.y });
            };
            const handleMove = (e) => {
                if (!dragStart) return;
                const coords = getCoordinates(e);
                setDragCurrent(coords);
            };
            const handleEnd = (e) => {
                if (!dragStart) return;
                const coords = getCoordinates(e);
                // Find target node (simple distance check)
                const target = G.nodes.find(n => Math.hypot(n.x - coords.x, n.y - coords.y) < 40);
                if (target && target.id !== dragStart.id) {
                    attemptConnection(dragStart, target);
                }
                setDragStart(null);
                setDragCurrent(null);
            };

            return (
                <div className="flex flex-col items-center w-full max-w-4xl mx-auto p-2">
                    {/* UI */}
                    <div className="flex flex-col items-center w-full mb-4 sticky top-16 z-20">
                        <h2 className="text-xl font-bold bg-white px-4 py-2 rounded-full shadow mb-2">Turno di {currentPlayer.name}</h2>
                        <div className="flex items-center gap-4 bg-white p-2 rounded-xl shadow-lg border">
                            <Die value={G.rolled ? G.currentRoll : localDieVal} shaking={localRolling} />
                            {isMyTurn && !G.rolled && !localRolling && <button onClick={animateAndRoll} className="bg-purple-600 text-white px-4 py-2 rounded-full font-bold shadow-md btn-press">LANCIA</button>}
                            <div className="font-bold text-gray-500 w-32 text-center">{G.rolled ? `Mosse: ${G.movesLeft}` : "Tira il dado!"}</div>
                        </div>
                    </div>

                    <div className="flex flex-wrap justify-center gap-4 mb-4 w-full">
                        {players.map(p => (
                            <div key={p.id} className={`flex items-center gap-2 px-3 py-1 rounded-full border-2 ${G.scores[p.id] > 0 ? 'bg-white' : 'bg-gray-100'}`} style={{borderColor: p.color}}>
                                <span>{p.avatar}</span>
                                <span className="font-bold">{G.scores[p.id] || 0}</span>
                            </div>
                        ))}
                    </div>

                    <div className="bg-white rounded-xl shadow-2xl border-4 border-gray-100 w-full overflow-hidden select-none" style={{touchAction: 'none'}}>
                         <svg 
                            ref={svgRef}
                            width="100%" 
                            height="500" 
                            viewBox="0 0 350 450"
                            onMouseMove={handleMove}
                            onMouseUp={handleEnd}
                            onTouchMove={handleMove}
                            onTouchEnd={handleEnd}
                            style={{cursor: isMyTurn && G.rolled ? 'crosshair' : 'default'}}
                        >
                            {/* Poligoni */}
                            {G.polygons && G.polygons.map((poly, i) => {
                                const owner = players.find(p => p.id === poly.ownerId);
                                const pts = poly.points.map(pid => {
                                    const n = G.nodes.find(node => node.id === pid);
                                    return `${n.x},${n.y}`;
                                }).join(' ');
                                return <polygon key={i} points={pts} fill={owner ? owner.color : '#ccc'} fillOpacity="0.4" stroke="none" />;
                            })}

                            {/* Linee */}
                            {G.edges && G.edges.map((e, i) => {
                                const n1 = G.nodes.find(n => n.id === e.u);
                                const n2 = G.nodes.find(n => n.id === e.v);
                                const owner = players.find(p => p.id === e.ownerId);
                                return <line key={i} x1={n1.x} y1={n1.y} x2={n2.x} y2={n2.y} stroke={owner ? owner.color : '#333'} strokeWidth="4" strokeLinecap="round" />;
                            })}

                            {/* Linea Drag */}
                            {dragStart && dragCurrent && <line x1={dragStart.x} y1={dragStart.y} x2={dragCurrent.x} y2={dragCurrent.y} stroke="#888" strokeWidth="3" strokeDasharray="5,5" />}

                            {/* Nodi */}
                            {G.nodes.map((n) => (
                                <circle 
                                    key={n.id}
                                    cx={n.x} cy={n.y} r="10"
                                    fill={dragStart && dragStart.id === n.id ? "#000" : "#555"}
                                    onMouseDown={(e) => handleStart(n, e)}
                                    onTouchStart={(e) => handleStart(n, e)}
                                    className="hover:r-12 transition-all cursor-pointer"
                                />
                            ))}
                        </svg>
                    </div>
                     <div className="text-center text-gray-400 mt-2 text-sm italic">Chiudi qualsiasi forma (triangoli, quadrati...) per fare punti!</div>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [user, setUser] = React.useState(null);
            const [localState, setLocalState] = React.useState(null);
            const [mode, setMode] = React.useState('home');
            const [profile, setProfile] = React.useState({ name: 'Player', color: COLORS[0], avatar: AVATARS[0] });
            const [activeLobbyId, setActiveLobbyId] = React.useState(null);
            const [gameData, setGameData] = React.useState(null);
            const [isOnline, setIsOnline] = React.useState(true);
            const [joinCode, setJoinCode] = React.useState('');

            React.useEffect(() => {
                const initAuth = async () => {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) await signInWithCustomToken(auth, __initial_auth_token);
                    else await signInAnonymously(auth);
                };
                initAuth();
                return onAuthStateChanged(auth, u => { if(u) { setUser(u); const s=localStorage.getItem('bg_profile'); if(s) setProfile(JSON.parse(s)); } });
            }, []);

            React.useEffect(() => {
                if (!activeLobbyId || !isOnline || !user) return;
                const unsub = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', activeLobbyId), s => {
                    if (s.exists()) setGameData(s.data());
                    else { setActiveLobbyId(null); setMode('home'); alert("Stanza chiusa."); }
                });
                return () => unsub();
            }, [activeLobbyId, isOnline, user]);

            const updateProfile = (newP) => { setProfile(newP); localStorage.setItem('bg_profile', JSON.stringify(newP)); };

            const createLobby = async (modeId) => {
                if (isOnline && !user) { alert("Attendi il caricamento dell'account..."); return; }

                let initial = { turnIndex: 0, message: "Inizia!", finishedPlayers: [] };
                
                if (modeId === 1) {
                    initial = { ...initial, boards: {}, dice: [1,1], rolled: false, usedDice: [] };
                } else if (modeId === 2) {
                    initial = { ...initial, glasses: [], centerContributors: {}, remainingMoves: 0 };
                } else if (modeId === 3) {
                    initial = { ...initial, playerData: {}, waitingReset: false };
                } else if (modeId === 4) {
                    initial = { ...initial, phase: 'setup', secretCode: [...GAME_COLORS], currentGuess: [], results: [], rounds: [], currentRoundIndex: 0 };
                } else if (modeId === 5) {
                    initial = { ...initial, lines: {}, boxes: {}, scores: {}, gridSize: { rows: 4, cols: 4 }, movesLeft: 0, rolled: false, currentRoll: 1 };
                } else if (modeId === 6) {
                    initial = { 
                        ...initial, 
                        edges: [], // {u, v, ownerId}
                        polygons: [], // {points: [id...], ownerId}
                        scores: {},
                        nodes: [], // populated later
                        movesLeft: 0,
                        rolled: false,
                        currentRoll: 1
                    };
                }
                
                const hostId = user ? user.uid : 'local_host';
                const newLobby = {
                    hostId: hostId, modeId, status: 'waiting', createdAt: Date.now(),
                    players: [{ id: hostId, name: profile.name, color: profile.color, avatar: profile.avatar }],
                    gameState: initial
                };

                if (isOnline) {
                    const code = generateCode();
                    await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', code), newLobby);
                    setActiveLobbyId(code);
                } else {
                    const local = { ...newLobby, players: [...newLobby.players, { id: 'local_p2', name: 'Giocatore 2', color: COLORS[1], avatar: AVATARS[1] }]};
                    setGameData(local); setLocalState(local); setActiveLobbyId('LOCAL');
                }
                setMode('lobby');
            };

            const joinLobby = async () => {
                if (!joinCode) return;
                if (!user) { alert("Attendi caricamento..."); return; }
                const ref = doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', joinCode.toUpperCase());
                const snap = await getDoc(ref);
                if (snap.exists() && snap.data().status === 'waiting' && snap.data().players.length < MODES.find(m=>m.id===snap.data().modeId).maxPlayers) {
                    await updateDoc(ref, { players: [...snap.data().players, { id: user.uid, name: profile.name, color: profile.color, avatar: profile.avatar }] });
                    setActiveLobbyId(joinCode.toUpperCase()); setMode('lobby');
                } else alert("Impossibile entrare.");
            };

            const startGame = async () => {
                let finalState = { ...gameData.gameState };
                const playerCount = gameData.players.length;

                if (gameData.modeId === 1) {
                    gameData.players.forEach(p => finalState.boards[p.id] = []);
                } else if (gameData.modeId === 2) {
                    if (playerCount !== 2) { alert("Servono 2 giocatori"); return; }
                    const emptyGlass = Array(13).fill(null);
                    finalState.glasses = [ { ownerId: gameData.players[0].id, dots: [...emptyGlass], total: 13 }, { ownerId: null, dots: [...emptyGlass], total: 13 }, { ownerId: gameData.players[1].id, dots: [...emptyGlass], total: 13 } ];
                } else if (gameData.modeId === 3) {
                    gameData.players.forEach(p => {
                        const d = [1,2,3,4,5,6,7,8,9,10].sort(() => Math.random() - 0.5);
                        finalState.playerData[p.id] = { cards: d, visible: Array(10).fill(false), target: 1 };
                    });
                } else if (gameData.modeId === 4) {
                    const ps = gameData.players;
                    const rounds = ps.map((p, i) => { const leaderIdx = (i - 1 + ps.length) % ps.length; return { guesserId: p.id, leaderId: ps[leaderIdx].id }; });
                    finalState.rounds = rounds; finalState.currentRoundIndex = 0; finalState.phase = 'setup'; finalState.secretCode = [...GAME_COLORS]; finalState.currentGuess = []; finalState.results = [];
                } else if (gameData.modeId === 5) {
                    let size = 6;
                    if (playerCount === 3) size = 7;
                    if (playerCount >= 4) size = 8;
                    finalState.gridSize = { rows: size, cols: size };
                    finalState.lines = {}; finalState.boxes = {}; finalState.scores = {};
                    gameData.players.forEach(p => finalState.scores[p.id] = 0);
                } else if (gameData.modeId === 6) {
                    finalState.nodes = []; // Force regen
                    finalState.edges = []; 
                    finalState.polygons = []; 
                    finalState.scores = {};
                    gameData.players.forEach(p => finalState.scores[p.id] = 0);
                }

                const updates = { status: 'playing', gameState: finalState };
                if (isOnline) await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', activeLobbyId), updates);
                else { const n = { ...gameData, ...updates }; setGameData(n); setLocalState(n); }
            };

            const updateGame = async (parts) => {
                const next = { ...gameData.gameState, ...parts };
                if (isOnline) await updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbies', activeLobbyId), { gameState: next });
                else { const n = { ...localState, gameState: next }; setGameData(n); setLocalState(n); }
            };

            if (mode === 'home') return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4">
                    <h1 className="text-5xl font-bold mb-4">Board<span className="text-green-500">Box</span></h1>
                    <div className="bg-white p-6 rounded-2xl shadow-xl w-full max-w-md">
                        <div onClick={() => setMode('customize')} className="flex items-center gap-4 mb-6 p-4 bg-gray-50 rounded-xl cursor-pointer">
                            <div className="w-12 h-12 rounded-full flex items-center justify-center text-2xl" style={{backgroundColor: profile.color}}>{profile.avatar}</div>
                            <div className="font-bold">{profile.name} <i className="fa-solid fa-pencil text-gray-400 text-xs"></i></div>
                        </div>
                        <div className="flex bg-gray-100 p-1 rounded-lg mb-4">
                            <button onClick={() => setIsOnline(true)} className={`flex-1 py-2 rounded font-bold text-sm ${isOnline ? 'bg-white shadow text-blue-600' : 'text-gray-400'}`}>ONLINE</button>
                            <button onClick={() => setIsOnline(false)} className={`flex-1 py-2 rounded font-bold text-sm ${!isOnline ? 'bg-white shadow text-green-600' : 'text-gray-400'}`}>LOCALE</button>
                        </div>
                        {isOnline ? (
                            <div className="flex gap-2 mb-4">
                                <input value={joinCode} onChange={e => setJoinCode(e.target.value)} placeholder="CODICE" className="flex-1 bg-gray-100 rounded px-4 font-mono font-bold uppercase" />
                                <button onClick={joinLobby} className="bg-blue-500 text-white font-bold px-4 py-3 rounded shadow btn-press">ENTRA</button>
                            </div>
                        ) : <div className="text-center text-gray-400 text-sm mb-4">Modalit√† Pass & Play</div>}
                        <div className="space-y-2">
                            {MODES.map(m => (
                                <button key={m.id} onClick={() => createLobby(m.id)} className="w-full text-left p-4 rounded-xl border hover:bg-green-50 flex items-center gap-4 btn-press">
                                    <div className="w-10 h-10 rounded-full bg-blue-100 text-blue-500 flex items-center justify-center"><i className={`fa-solid ${m.icon}`}></i></div>
                                    <div><div className="font-bold">{m.name}</div><div className="text-xs text-gray-400">{m.desc}</div></div>
                                </button>
                            ))}
                        </div>
                    </div>
                </div>
            );

            if (mode === 'customize') return (
                <div className="min-h-screen flex flex-col items-center justify-center p-4 bg-white">
                    <h2 className="text-2xl font-bold mb-6">Profilo</h2>
                    <div className="w-full max-w-md space-y-4">
                        <input value={profile.name} onChange={e => updateProfile({...profile, name: e.target.value})} className="w-full text-2xl font-bold border-b-2 py-2" placeholder="Nome" />
                        <div className="flex flex-wrap gap-2">{COLORS.map(c => <button key={c} onClick={() => updateProfile({...profile, color: c})} className={`w-8 h-8 rounded-full ${profile.color===c?'ring-2 ring-black':''}`} style={{backgroundColor: c}} />)}</div>
                        <div className="flex flex-wrap gap-2 bg-gray-50 p-2 rounded">{AVATARS.map(a => <button key={a} onClick={() => updateProfile({...profile, avatar: a})} className={`text-2xl w-10 h-10 rounded ${profile.avatar===a?'bg-white shadow':''}`}>{a}</button>)}</div>
                        <button onClick={() => setMode('home')} className="w-full bg-black text-white py-3 rounded-xl font-bold btn-press">SALVA</button>
                    </div>
                </div>
            );

            if (mode === 'lobby' && gameData) {
                const activeMode = MODES.find(m => m.id === gameData.modeId);
                const isHost = gameData.hostId === user?.uid || !isOnline;
                let effectiveMyId = isOnline ? (user?.uid) : null;
                
                if (!isOnline) {
                    if (gameData.modeId === 4) {
                        if (gameData.status === 'playing' && gameData.gameState.rounds) {
                             const round = gameData.gameState.rounds[gameData.gameState.currentRoundIndex];
                             if (round) {
                                if (gameData.gameState.phase === 'setup') effectiveMyId = round.leaderId;
                                else if (gameData.gameState.phase === 'guessing') effectiveMyId = round.guesserId;
                                else effectiveMyId = gameData.hostId;
                             }
                        } else effectiveMyId = gameData.hostId;
                    } else effectiveMyId = gameData.players[gameData.gameState.turnIndex]?.id;
                }

                if (gameData.status === 'playing') return (
                    <div className="min-h-screen pb-10">
                        <div className="bg-white p-3 shadow mb-4 flex justify-between items-center">
                            <div className="font-bold flex items-center gap-2"><i className={`fa-solid ${activeMode.icon}`}></i> {activeMode.name}</div>
                            <button onClick={() => {if(confirm("Uscire?")) {setMode('home'); setActiveLobbyId(null);}}} className="text-red-500 text-sm font-bold bg-red-50 px-3 py-1 rounded-full">ESCI</button>
                        </div>
                        {gameData.modeId === 1 && <GameFirstTo10 G={gameData.gameState} players={gameData.players} myPlayerId={effectiveMyId} updateGame={updateGame} />}
                        {gameData.modeId === 2 && <GameGrapes G={gameData.gameState} players={gameData.players} myPlayerId={effectiveMyId} updateGame={updateGame} />}
                        {gameData.modeId === 3 && <GameCards G={gameData.gameState} players={gameData.players} myPlayerId={effectiveMyId} updateGame={updateGame} />}
                        {gameData.modeId === 4 && <GameGuessColor G={gameData.gameState} players={gameData.players} myPlayerId={effectiveMyId} updateGame={updateGame} />}
                        {gameData.modeId === 5 && <GameDotsAndBoxes G={gameData.gameState} players={gameData.players} myPlayerId={effectiveMyId} updateGame={updateGame} />}
                        {gameData.modeId === 6 && <GameRandomDots G={gameData.gameState} players={gameData.players} myPlayerId={effectiveMyId} updateGame={updateGame} />}
                    </div>
                );
                return (
                    <div className="min-h-screen flex flex-col items-center p-4">
                        <div className="bg-white w-full max-w-md rounded-2xl shadow-xl overflow-hidden">
                            <div className="bg-indigo-600 p-6 text-white text-center">
                                <h2 className="text-2xl font-bold">{activeMode.name}</h2>
                                {isOnline ? <div className="mt-2 text-3xl font-mono font-bold tracking-widest bg-white/20 rounded py-1">{activeLobbyId}</div> : <div className="mt-2">Locale</div>}
                            </div>
                            <div className="p-6 space-y-3">
                                {gameData.players.map(p => (
                                    <div key={p.id} className="flex items-center gap-3 bg-gray-50 p-2 rounded-lg">
                                        <div className="w-10 h-10 rounded-full flex items-center justify-center text-xl text-white" style={{backgroundColor: p.color}}>{p.avatar}</div>
                                        <div className="font-bold">{p.name}</div>
                                    </div>
                                ))}
                                {isHost ? (
                                    <button onClick={startGame} disabled={gameData.players.length < activeMode.minPlayers} className={`w-full py-3 rounded-xl font-bold text-lg mt-4 ${gameData.players.length < activeMode.minPlayers ? 'bg-gray-200 text-gray-400' : 'bg-green-500 text-white btn-press'}`}>INIZIA</button>
                                ) : <div className="text-center text-gray-400 mt-4 animate-pulse">In attesa dell'host...</div>}
                                <button onClick={() => {setMode('home'); setActiveLobbyId(null);}} className="w-full text-gray-400 font-bold py-2">Esci</button>
                            </div>
                        </div>
                    </div>
                );
            }
            return <div className="text-center mt-20">Caricamento...</div>;
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>